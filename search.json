[
  {
    "objectID": "tutorials/study_cases.html",
    "href": "tutorials/study_cases.html",
    "title": "Study Cases",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nParameter studies are organized in study cases, operation scenarios and variations in PowerFactory. This tutorials shows how to create parameter studies with ease and fully automated using the study cases interface of powfacpy.\nFirst, we activate the PowerFactory project as in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\n\n1 Simple Parameter Study\nWe use the class StudyCases. This class inherits from PFActiveProject, so all methods from that class are available. We want to create study case with various values for the active and reactive power of a load.\nFirst we set the attribute parameter_values and define a dictionary with parameter names and a list of values. Each element in the lists is used in one study case.\n\nfrom powfacpy.applications.study_cases import StudyCases\n\npfsc = StudyCases(app)\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc.parameter_values = {\n    \"p HV load\": [1,   2, 1, 2],\n    \"q HV load\": [-1, -1, 1, 1], \n}\n# fmt: on\n\nHere we have defined four study cases and in the first case p HV load equals 1 and q HV load equals -1. The parameter names must not contain *?=“,~|()! as these characters cannot be used for names of objects in PF.\nNext we connect the variables to the PF database by defining a dictionary with paths in the attribute parameter_paths using the same parameter names as keys. The paths include the attribute name (e.g. plini which is the active power of the load).\n\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\",  # This is one string split over several lines\n    \"q HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\n\nFinally we define the active grids. For now, we assume that for all cases exactly one grid is active (we look at more complicated cases later).\n\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\nNow let’s create the study cases (and corresponding operation scenarios) in a new folder named ‘Autocreated’:\n\npfsc.parent_folder_study_cases = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.study_cases_folder\n)\npfsc.parent_folder_scenarios = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.operation_scenarios_folder\n)\n# Alternatively, just use\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\npfsc.create_cases()\n\nThis creates the following study cases in the ‘Autocreated’ folder:\n\nThe names of the study cases are created according to the parameter names and their values (“_” is used instead of “=” which is not allowed in PF object names). Furthermore, the corresponding operation scenarios are created:\n\nFor more complicated case studies with further parameters, it is advisable to structure the cases in folders. We define the attribute hierarchy using a list (in this case with onl yone item) of parameter names that corresponds to folder directories.\n\npfsc.hierarchy = [\"q HV load\"]\npfsc.create_cases()\n\nNow q HV load is used for the folder names and not in the study case name.\n\nThe structure of the operation scenarios is similar.\n\n\n2 Advanced Parameter Study\nLet’s take a look at a more complex parameter study.\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc = StudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":    [1,   2, 2,  1,  1,  2,  1,  2,],\n    \"q HV load\":    [-1, -1, 1,  1,  -1, -1, 1,  1,],\n    \"control\":      [\"A\",\"A\",\"A\",\"A\",\"B\",\"B\",\"B\",\"B\"],\n}\n# fmt: on\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\plini\",\n    \"q HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n\nAn additional parameter control is defined. Note that there is no parameter path defined for this parameter. The parameter can be seen as a placeholder for the study cases structure and to do more complicated things than simply setting an attribute of a PF object later (we’ll see below).\nBy default, study cases and operation scenarios are created. If variations should be created in addition, use:\n\npfsc.add_variation_to_each_case = True\n\nThis can be necessary because some parameters, like attributes of DSL objects, are stored in variants and not in operation scenarios. Let’s again create the study cases.\n\npfsc.hierarchy = [\"control\", \"q HV load\"]\npfsc.create_cases()\n\nThis creates the following structure in the network variations (as well as in the scenarios and study cases):\n\nLet’s set further parameters, add plots (using plot interface) and simulate (using dyn. simulation interface) for each study case. The study case objects are stored in the study_cases attribute. We can iterate through the cases and set parameters depending on the previously defined control parameter.\n\nfrom powfacpy.applications.plots import Plots\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\n\npfpi = Plots(app)\npfds = DynamicSimulation(app)\ndsl_controller_obj = pfsc.act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\n\n\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    study_case_obj.Activate()\n    # Set controller parameters\n    if pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"A\":\n\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 0, \"VFlag\": 1})\n    elif pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"B\":\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 1, \"VFlag\": 0})\n    # Prepare plots\n    pfpi.clear_plot_pages()\n    pfpi.set_active_plot(\"Reactive current\", \"WPP\")\n    pfpi.plot(dsl_controller_obj, \"s:Iqcmd\")\n    # Simulate\n    pfds.initialize_and_run_sim()\n\nLet’s walk through this piece of code. The plotting and simulation interfaces are instantiated and a DSL object is assigned to be used later.\nIt is iterated through the study cases objects (and case numbers) and each study case is activated. Then the controller parameters are set. The value of the control parameter is obtained using the method get_value_of_parameter_for_case and the controller parameters are set depending on the controller type (A or B). This provides the flexibility to adjust the study cases depending on previously defined parameters in any way (e.g. set parameters, activate grids, …). And all settings are stored in the previously defined operation scenarios/variations.\nFinally, a plot is created for every case and the dynamic simulation is executed.\n\n\n3 Compare Study Cases\nIt is often required to compare the results of cases. In the following, we use the previously defined cases to compare the simulation results for cases where the parameter p HV load equals 1 (note that you may have to “Rebuild”  the plot in the upper left for PF to show it correctly):\n\n# Create a study case where results from other cases are compared in a plot\nstudy_case_comparison = pfsc.act_prj.create_by_path(\n    r\"Study Cases\\Autocreated\\Comparison.IntCase\"\n)\nstudy_case_comparison.Activate()\npfpi.clear_plot_pages()\npfpi.set_active_plot(\n    \"Reactive current controller setpoint for p HV load = 1\", \"Comparison \"\n)\ndsl_controller_obj = (\n    r\"Network Model\\Network Data\\test_case_studies\"\n    r\"\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    if pfsc.get_value_of_parameter_for_case(\"p HV load\", case_num) == 1:\n        # Get results object from respective study case\n        results_obj = pfsc.act_prj.get_unique_obj(\n            \"*.ElmRes\", parent_folder=study_case_obj\n        )\n        # Create label for plot\n        case_label = pfsc.get_case_params_value_string(\n            case_num, omitted_parameters=\"p HV load\", delimiter=\" | \", equals_sign=\"=\"\n        )\n        label = \"Iq setpoint (\" + case_label + \")\"\n        # Plot\n        pfpi.plot(dsl_controller_obj, \"s:Iqcmd\", results_obj=results_obj, label=label)\n\nThis creates a plot with legend:\n\nLet’s walk through the code. After creating a study case where the results are compared in a plot, it is again iterated through all cases. For cases where p HV load has a certain value, the result object is fetched. Next we want to create a label for the curve in the plot. We use the method get_case_params_value_string with certain options for the delimiter and the equals symbol (here we have more options than for PF object names, i.e. = and | are allowed). Moreover, the parameter p HV load is omitted because it is the same for all compared cases (i.e. 1, see condition). Further information on the variable is added to the label and the curve is finally added to the plot.\nAn alternative to iterating through all study cases is to get certain cases using the method get_study_cases:\n\nstudy_cases_p_HV_load_equals_1 = pfsc.get_study_cases({\"p HV load\": lambda x: x == 1})\nfor study_case_obj in study_cases_p_HV_load_equals_1:\n    pass\n    # do something with the specific cases\n\nget_study_cases takes a dictionary as input, where lambda functions with conditions for parameters are defined. Note that the methods get_value_of_parameter_for_case and get_case_params_value_string also work with study case objects as inputs instead of case numbers.\nA very convenient yet powerful alternative to ‘get_study_cases’ especially for complicated conditionals is ‘get_study_cases_from_string’. This method simply accepts a string which can contain complicated conditionals:\n\nstudy_cases_from_conditionals = pfsc.get_study_cases_from_string(\n    \"p HV load &gt;= 2 and (control == 'A' or q HV load != 1)\"\n)\n\nThat makes it very easy to plot and compare certain cases.\n\n\n4 Permutation\nIt is also possible to create study cases for the permutation of the parameters (i.e. all combinations). This is achieved with the method apply_permutation. Define the parameter values first (and also the hierarchy if applicable) and then call the method. Make sure that the PF application is hidden to improve the performance (if not hidden, this can take minutes and otherwise only seconds - the ‘try-finally’ block ensures that the app is always shown in the end even if an exception is thrown):\n\ntry:\n    pfsc = StudyCases(app)\n    pfsc.act_prj.app.Hide()\n    pfsc.parameter_values = {\n        \"p HV load\": [1, 2, 3],\n        \"q HV load\": [-1, 1],\n        \"control 1\": [\"A\", \"B\"],\n        \"control 2\": [\"R\", \"S\"],\n    }\n    pfsc.hierarchy = [\n        \"p HV load\",\n        \"control 1\",\n    ]\n    pfsc.apply_permutation()\n    pfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    pfsc.act_prj.app.Show()\n\napply_permutation irreversibly replaces the values in parameter_values with the permutation.\nIt may be desirable to use the permutation but omit certain combinations. These omitted combinations can be defined in a list of dictionaries and used as a keyword argument as follows (note that we clear the parent folders from the formerly created objects first):\n\ntry:\n    app.Hide()\n    omitted_combinations = [\n        {\"q HV load\": [1], \"control 2\": [\"R\"]},\n        {\"p HV load\": [2, 3], \"control 1\": \"all\"},\n    ]\n    pfsc.apply_permutation(omitted_combinations=omitted_combinations)\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    app.Show()\n\nThe first dictionary causes any combinations where “q HV load” is 1 and “control 2” is “R” to be omitted (these cases will not be created when create_cases is called). In the second dictionary, the keyword “all” is used. This means that all combinations with this parameter are omitted.\n\n\n5 Further Functionality\nThe attributes of StudyCases instances allow to set further options.\nThe study case names can be numbered consecutively setting consecutively_number_case_names.\nSometimes it is convenient to use only parameter values without the parameter names for the folder/study case names (imagine the value of a parameter is expressive enough and you don’t want to use “Controller_GridCode2012Controller” but only “GridCode2012Controller” instead). This can be achieved by adding parameters to the list of anonymous_parameters (e.g. pfsc.anonymous_parameters=[\"Controller\",\"FurtherParName\"]).\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nThis tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\n\nThen import powfacpy and create an instance of class PFActiveProject (with argument app). This interface class is mainly used to interact with the active project in the PowerFactory database as we will see below.\n\nfrom powfacpy.base.active_project import ActiveProject\n\npfp = ActiveProject(app)\n\nNote that pfp has an attribute app that can be used similar to the app variable we loaded from the powerfactory module.\nThe PowerFactory project used in this tutorial can be found in the powfacpy repository under *tests_input_tests.pfd*.\nHere are two ways to 1. show the PowerFactory application and 2. activate a project:\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\npfp.app.Show()\npfp.app.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\nSo where does pfp differ from the Python interface that app provides? Let’s see.\n\n1 Accessing Objects\nLet’s access an object from the PowerFactory database. When using app, we would use the methods app.GetProjectFolder, app.GetChildren or app.GetContents. Instead, we use pfp.get_obj with the path of the object (relative to the folder of the active project) as an argument:\n\nmv_terminal = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\"\n)[0]\n\nThe [0] at the end is necessary because the method always returns a list (with one element in this case).\nNote that you can easily copy and paste the path from the data manager while selecting the object in the data tree:\n\n\n\nobject path\n\n\npfp.get_obj also differs in other ways from app.GetContents and app.GetCalcRelevantObjects. You can set a condition for the objects that you want to access, which is best described by an example:\n\nhv_terminals = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\",\n    condition=lambda x: x.uknom &gt; 50,\n)\n\nFirst of all, we use a wildcard (*.ElmTerm) to access all terminals in the Grid folder. The condition argument is a function that defines a certain condition the objects have to fulfill and returns a boolean value. In this case, the input argument x is an ElmTerm and x.uknom &gt; 50 gets its attribute uknom (nominal voltage) and checks whether it is larger than 50 (kV). Using this .uknom notation is equivalent to using getattr(x, \"uknom\"), which is a python method that returns an attribute of any object (also PowerFactory objects). You can also define more complex functions, such as lambda x: x.uknom &gt; 50 and x.uknom &lt; 200 to access terminals between 50 and 200 kV.\nIt is also possible to include subfolders in the search for objects:\n\nterminals = pfp.get_obj(\n    r\"Network Model\\Network Data\\*.ElmTerm\", include_subfolders=True\n)\n\nThis will search in Network Model\\Network Data and all its subfolders (by default include_subfolders is False, be carefull as including all subfolders in the search can affect the performance).\nWhat’s also very helpful is that pfp.get_obj throws an error if the path is incorrect and shows exactly where it fails. So\nterminals = pfp.get_obj(r\"Network Model\\wrong_folder_name\\*.ElmTerm\")\nwill throw an error:\nPFPathError: ‘wrong_folder_name’ does not exist in ’_baseModel’\nBy default, an exception is also raised if no objects are found in the specified folder. For example:\nterminals = pfp.get_obj(r\"Network Model\\Network Data\\wrong_object_name*\", include_subfolders=True)\nreturns\nPFPathError: ’wrong_object_name*’ does not exist in ’_baseModelData’\nThis can be turned off by setting the optional argument error_if_non_existent=False, then an empty list will be returned.\nIf you want to access objects in a folder many times and don’t want to use the whole path relative to the active project every time, you can also specifiy a parent folder where the search path starts (this can also be more performant):\n\ngrid_folder = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\"\n)[0]\n\nmv_terminal = pfp.get_obj(\"Terminal MV\", parent_folder=grid_folder)[0]\nhv_terminal = pfp.get_obj(\"Terminal HV 1\", parent_folder=grid_folder)[0]\n\nYou can also use brackets to call get_obj (the PFActiveProject class defines a __getitem__ method that calls get_obj without optional arguments):\n\nterminals = pfp[\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\"\n]\n\nThe get_obj command can become verbose with many keyword arguments. This can be inconvenient, for example when you have to call the method many times with the same arguments. powfacpy provides the get_object_partial method which returns a Callable. This way you can define new variations of get_obj:\n\nget_obj_subf = pfp.get_obj_partial(include_subfolders=True)\n# This can now be used with further arguments of 'get_obj' as follows (and will always assume 'include_subfolders=True'):\nterminals = get_obj_subf(\"*.ElmTerm\", parent_folder=grid_folder)\n\nUnder the hood the partial function from the built-in functools module of Python is used (it is actually pretty simple to do the above with any Python method/function). Note that for the commonly required inclusion of subfolders in the search there is actually a separate method get_obj_including_subfolders available (another alternative for network objects in get_calc_relevant_obj as described below).\nAn alternative to pfp.get_obj is pfp.get_unique_obj. Use this function if you want to access a single unique object (i.e. an object that you expect to only exist once) from the database and want to avoid the [0] (which is easily forgotten).\n\nterminal_1 = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\n\nget_unique_obj will throw an error if the specified path is not attributable to a single unique object (i.e. also when two or more objects are found).\nFinally, yet another alternative for getting network objects is get_calc_relevant_obj: powfacpy wraps the GetCalcRelevenatObjects method and adds optional arguments, similar to get_obj:\n\nterminals = pfp.get_calc_relevant_obj(\n    \"ElmTerm\", error_if_non_existent=False, includeOutOfService=0\n)\n\n\n\n2 Accessing Project Folders and Data\nThe PFActiveProject class defines a number of properties to directly access relevant project folders (under the hood, the GetProjectFolder and GetDataFolder methods are used). Here are some examples (you may just type pfp.folder and your IDE will autocomplete all the properties):\n\npfp.study_cases_folder  # This is a getter property returning StudyCases.IntPrjfolder\npfp.network_model_folder\npfp.zones_folder\npfp.variations_folder\npfp.operation_scenarios_folder\n# ...\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Operation Scenarios.IntPrjfolder&lt;/l1&gt;&gt;\n\n\nTo get all active grids/networks (ElmNet) use:\n\nactive_networks = pfp.get_active_networks()\n# pfp.app.GetCalcRelevantObjects(\".ElmNet\") also returns the summary grid in the study case which is usually not desired.\n\n\n\n3 Getting Objects from the Active Study Case\nThe native GetFromStudyCase method returns the first object found that satisfies the criteria or creates a new object in the active study case. This is a common source of errors when more than one object satisfies the criteria and this goes unnoticed (this often happens for example when users work on the same project with different language settings). You can use the powfacpy method instead which prints a warning or raises an error if the the object found is not unique:\n\nresults_obj = pfp.get_from_study_case(\"ElmRes\", if_not_unique=\"warning\")\n\nd:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\docs\\tutorials\\..\\..\\src\\powfacpy\\base\\active_project.py:173: UserWarning: The returned *.ElmRes object is not unique in the  study case: 'Study Cases\\test_active_project_interface\\Study Case 1'. Make sure that the correct *.ElmRes object is used.\n  warn(\n\n\n\n\n4 Type Hints\nType hints are used in Python to improve the readability and code completion, but do not actually affect the excuted code (except when you do static type checking). They are often seen in function/method definitions and are preceded by a colon, e.g.:\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nThis means that the function expects two input arguments of type integer and returns an integer. powfacpy defines protocol classes for (almost) all PowerFactory classes (more than 200) from the scripting reference (with very few exceptions) and a few additional classes (such as ‘IntSite’ which is not mentioned in the scripting reference).\nIn the following example a type hint is used (‘:ElmTerm’). Your IDE will then autocomplete all attributes (methods and data) of the variable ‘terminal’:\n\nfrom powfacpy.pf_class_protocols import ElmTerm\n\nterminal: ElmTerm = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\nterminal.uknom\n\n110.0\n\n\nAny modern IDE should autocomplete your code while writing:\n\n\n\ntype_hints\n\n\nNote that this also works with lists:\n\nterminals: list[ElmTerm] = pfp.get_calc_relevant_obj(\"ElmTerm\")\n\n\n\n5 Setting and Getting Object Attributes\nHow about setting data in the database? You can set attributes of an object as follows:\n\npfp.set_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    {\"uknom\": 33, \"outserv\": 0},\n)\n\nSo with only one command we set the attributes “uknom” and “outserv” of the terminal. This saves time and is also very readable code. Note that the method set_attr accepts the path (string) but also a PowerFactory object. For example, we could also use the object mv_terminal that we loaded above:\n\npfp.set_attr(mv_terminal, {\"uknom\": 33, \"outserv\": 0})\n\nThis applies to many other methods in powfacpy. Loading the object only once and then using the object can be more efficient than using the path string many times.\nIf you want to get an attribute of an object, write:\n\nnominal_voltage = pfp.get_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    \"uknom\",\n)\n\n\n# Equivalent:\nnominal_voltage = pfp.get_attr(mv_terminal, \"uknom\")\nnominal_voltage = pfp.get_attr(\n    \"Terminal MV\",\n    \"uknom\",\n    parent_folder=r\"Network Model\\Network Data\\test_active_project_interface\\Grid\",\n)\n\n\n\n6 Creating Objects and Directories\nIf you want to create a new object, use:\n\nfrom powfacpy.pf_class_protocols import BlkDef, IntPrjfolder\n\nnew_obj: BlkDef = pfp.create_by_path(r\"Library\\Dynamic Models\\dummy.BlkDef\")\n\nThis will create an object of class “BlkDef” with the name “dummy” in the folder “LibraryModels”. You can also use\n\nnew_obj: BlkDef = pfp.create_in_folder(\n    \"dummy.BlkDef\", r\"Library\\Dynamic Models\", overwrite=True\n)\n\n\n# Or equivalent:\nmodels_folder: IntPrjfolder = pfp.get_unique_obj(r\"Library\\Dynamic Models\")\nnew_obj: BlkDef = pfp.create_in_folder(\"dummy.BlkDef\", models_folder, overwrite=True)\n\nwhich will overwrite the former object (this avoids that PowerFactory creates dummy(1), dummy(2), … every time the code is run). overwrite=True is the default setting.\nTo create a directory, i.e. a nested folder structure, use\n\npfp.create_directory(\n    r\"New Study Case\\Cases Normal Opration\", parent_folder=\"Study Cases\"\n)\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\New Study Case\\Cases Normal Opration&lt;/l1&gt;&gt;\n\n\n\n\n7 Copying Objects\nThe method copy_obj can be seen as a method that uses get_obj as a first step to access objects and then copies them to a target folder under the hood. Therefore, copy_obj shares many (optional) input arguments with get_obj to first get the objects to be copied. Additionally, a target folder is required. For example, to copy all objects from a source folder to a target folder, write\n\nsource_folder = r\"Library\\Dynamic Models\\TestDummyFolder\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nnew_copied_objects = pfp.copy_obj(\"*\", target_folder, parent_folder=source_folder)\n\nNote that parent folder is an optional argument (used for the source), so you could also specify the full object path as the first argument instead of using * (similar to get_obj). To select certain objects from the source folder, you can use optional arguments like condition or include_subfolders, also similar to the get_obj method. The method also accepts a list of PowerFactory objects:\n\nlist_of_objects_to_copy = pfp.get_obj(\"*\", parent_folder=source_folder)\ntarget_folder_obj = pfp.get_unique_obj(r\"Library\\Dynamic Models\\TestCopyMultiple\")\nnew_copied_objects = pfp.copy_obj(\n    list_of_objects_to_copy, target_folder_obj, overwrite=True\n)\n\nNote that the target folder object (instead of a path string) is used (second argument).\nIf you want to copy a single object, use copy_single_obj. You have the option to give it a new name (loc_name attribute):\n\nnew_copy = pfp.copy_single_obj(\n    r\"Library\\Dynamic Models\\Linear_interpolation\",\n    r\"Library\\Dynamic Models\\TestCopy\",\n    new_name=\"new_dummy_name\",\n)\n\nFirst input here is the path of the object to be copied, but you can also use a PowerFactory object.\n\n\n8 Deleting Objects\nDeleting objects works in a similar fashion, because under the hood it uses get_obj and deletes the returned objects in the second step.\n\npfp.delete_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    include_subfolders=True,\n    error_if_non_existent=False,\n)\n\nAnd of course you could also use PowerFactory objects as an input:\n\nobjects_in_folder = pfp.get_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    error_if_non_existent=False,\n)\n\npfp.delete_obj(objects_in_folder, error_if_non_existent=False)\n\nYou can also delete all objects in a folder:\n\npfp.clear_folder(\"Library\\Dynamic Models\\TestDelete\")\n\n\n\n9 Further Useful Methods\nFurther helpful methods are briefly described in the following. get_upstream_obj returns an upsream object that meets a condition (i.e. the method goes upwards in the folder hierarchy until a parent object is found that meets the condition).\nHere this is used to find the grid that contains a given object:\n\nobj = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_database_interface\\Grid\\Voltage source ctrl\\Frequency\"\n)\ngrid = pfp.get_upstream_obj(obj, lambda x: x.loc_name == \"Grid\")\nprint(pfp.get_path_of_object(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\n\n\nget_path_of_object returns the path of an object relative to the active project and without any class names. The user can can directly copy the returned string to the data manager to quickly find the object in the PowerFactory app.\n\n\n\nobject path\n\n\nThere are more methods to get the path of an object:\n\nprint(pfp.get_path_of_object(grid))  # path inside project\nprint(pfp.get_path_of_obj_with_class_names(grid))\nprint(pfp.get_full_path_of_object(grid))  # full path in database\nprint(pfp.get_full_path_of_object_with_class_names(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\\seberlein\\powfacpy\\powfacpy_tests_copy_where_tests_run\\Network Model\\Network Data\\test_database_interface\\Grid\n\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\n\n\n\n10 The Folder Class\nMost of the functionality described above is not limited to the folder of the active project, but can be used with any folder in the database. The class ‘Folder’ can be used with any folder. Path input arguments are then relative to that folder (and not to the active project as above, unless of course a ‘parent_folder’ is specified):\n\nfrom powfacpy.base.folder import Folder\n\nnetwork_data_folder = Folder(r\"Network Model\\Network Data\", app)\n\n\ngrid = network_data_folder.get_unique_obj(\n    \"test_active_project_interface\\Grid\"\n)  # relative to 'Network Data' folder\n\n\nprint(network_data_folder.get_path_of_object(grid))\n\ntest_active_project_interface\\Grid\n\n\nNote that ‘Folder’ instances are iterable. For example, you can use a for-loop to iterate through the (direct) children of the folder:\n\nfor object in network_data_folder:\n    print(network_data_folder.get_path_of_object(object))\n\nAreas\nBackbones\nVirtual Power Plants\nBoundaries\nCable Layouts\nCircuits\nDistribution correlations\nFeeders\nMeteo Stations\nOperators\nOwners\nPaths\nRoutes\nZones\ntest_plot_interface\nnetwork_for_elmfiles\ntest_case_studies\ntest_dyn_sim_interface\ntest_active_project_interface\ntest_network_interface\ntest_results_interface\ntest_database_interface\ntest_model_exchange_interfaces\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html",
    "href": "docs/tutorials/simulation_and_plotting.html",
    "title": "Simulation and Plotting",
    "section": "",
    "text": "The following tutorial introduces dynamic simulations (RMS/EMT), plotting and exporting of results (to pandas or csv) using powfacpy.\nLet’s again set up PowerFactory and create an instance of powfacpy’s Plots class. This class inherits from ActiveProject (so those methods are available). We use the ‘39-Bus New England’ example from PowerFactory (see File-&gt;Examples).\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\nfrom powfacpy.applications.plots import Plots\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\n\npfplt = Plots(app)\nstudy_case = pfplt.act_prj.activate_study_case(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\"\n)",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "href": "docs/tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "title": "Simulation and Plotting",
    "section": "3.1 Export to Pandas DataFrame",
    "text": "3.1 Export to Pandas DataFrame\nLet’s export dynamic simulation results to a Pandas DataFrame. We’ll hide the PowerFactory app to improve the performance.\n\ntry:\n    app.Hide()\n    pfds.act_prj.clear_elmres()\n    pfds.act_prj.add_results_variable(\n        [\n            r\"Network Model\\Network Data\\Grid\\G 01\",\n            r\"Network Model\\Network Data\\Grid\\G 02\",\n        ],\n        [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value],\n    )\n    pfds.initialize_and_run_sim()\n    df_sim_res = pfres.export_to_pandas()\nfinally:\n    app.Show()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\nGrid\\G 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nMulti index column labels are used by default. The first index is the path of the object inside the network data folder and the second index is the variable name.\nYou can also use single index column format:\n\npfres.multi_index_labels = False\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\\s:P1\nGrid\\G 01\\s:Q1\nGrid\\G 02\\s:P1\nGrid\\G 02\\s:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nIt is also possible to set the actual PF objects as labels:\n\npfres.pf_objects_in_labels = True\npfres.multi_index_labels = True\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 01.ElmSym&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 02.ElmSym&lt;/l3&gt;\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nThe column headers are the path of the objects relative to the network data folder (by default) together with the result variable name. You can change the relative path by setting the attribute pfres.truncate_paths_until (relative to active project):\n\npfres.multi_index_labels = True\npfres.pf_objects_in_labels = False\npfres.truncate_paths_until = \"Network Model\\\\Network Data\\\\Grid\\\\\"\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\nG 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\npowfacpy offers methods to easily extract results from the exported pandas DataFrame using PowerFactory objects instead of columns headers (note that changing the format of the column headers of the DataFrame after export will break this functionality):\n\nimport matplotlib.pyplot as plt\n\np_g_01 = pfres.get_simulation_results_from_dataframe(\n    df_sim_res,\n    g_01,  # accepts using PF objects of their path inside the active project)\n    RMS_bal.ElmSym.s_P1.value,\n)\np_g_01.plot(grid=True)\nplt.legend()\np_g_01.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\n\n\ntime\n\n\n\n\n\n-0.10\n1000.0\n\n\n-0.09\n1000.0\n\n\n-0.08\n1000.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s look a more complicated example where you want to examine the active and reactive power of the synchronous machines G 01 and G 02.\n\n# SM objects\nsm_objs = [\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 01\"),\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 02\"),\n]\n\n# Results variables\nsm_res_var = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\n\npfres.act_prj.clear_elmres()\npfres.act_prj.add_results_variable(sm_objs, sm_res_var)\npfdi = DynamicSimulation(app)\npfdi.initialize_and_run_sim()\n\nWe want to add a legend to the plots. As the default variable and object names might not be very descriptive, powfacpy allows to define aliases, e.g. to be used later for labels in plots:\n\npfres.variable_aliases = {\n    RMS_bal.ElmSym.s_P1.value: \"Active Power\",\n    RMS_bal.ElmSym.s_Q1.value: \"Reactive Power\",\n}  # note that RMS_bal.ElmSym.s_P1.value gives 's:P1'\n\npfres.obj_aliases = {\n    \"G 01\": \"Synch. Maschine 1 (large)\",\n    \"G 02\": \"Synch. Maschine 2\",\n}\n\nLet’s see how the variable_aliases dictionary can then be used when plotting active and reactive power of G 01 using replace_variable_aliases:\n\ndf_sim_res = pfres.export_to_pandas()\nfor var in sm_res_var:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm_objs[0], var)\n    label = pfres.replace_variable_aliases(var)\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nInstead of s:P1 or s:Q1, the replacements defined in the dictionaries above are used for the labels.\nOr in a similar fashion, using also the object_aliases to plot the reactive power of both machines:\n\nvar = RMS_bal.ElmSym.s_P1.value\nfor sm in sm_objs:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm, var)\n    label = (\n        pfres.replace_object_aliases(sm.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nHence, the dictionaries are a clean option to define aliases and reuse them anywhere in your code.\nNote that get_simulation_results_from_dataframe also accepts a list of objects (as well as a list of variables). You can easily get various time series results and then process the data using pandas (e.g. calculate mean or average):\n\nvar = RMS_bal.ElmSym.s_P1.value\nres = pfres.get_simulation_results_from_dataframe(\n    df_sim_res, sm_objs, var  # list with G 01 and G 02\n)\n\nmean = res.mean(1)  # pandas method to get mean over axis 1\nsum = res.sum(1)\n\n# Plot active power of individual SMs\nfor sm_num, sm_obj in enumerate(sm_objs):\n    label = (\n        pfres.replace_object_aliases(sm_obj.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res.iloc[:, sm_num], label=label)\n\n# Plot mean and sum\nlabel_sms = \", \".join([pfres.replace_object_aliases(sm.loc_name) for sm in sm_objs])\nlabel = \"MEAN of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(mean, label=label)\nlabel = \"SUM of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(sum, label=label)\nplt.legend(loc=\"lower center\", bbox_to_anchor=(0.5, 1.0))\nplt.grid()\n\n\n\n\n\n\n\n\nNote that the same code block can be used with other result variables (e.g. reactive power) just by changing the var assignment in the first line.\nBy default, export_to_pandas exports all monitored variables of the first ElmRes object found in the active study case. Alternatively, selections of network elements and the respective variables as well as results objects (ElmRes) can be specified as lists:\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\ndf_sim_res = pfres.export_to_pandas(\n    list_of_results_objs=elmres_list, elements=elements, variables=variables\n)\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n\n\n-0.09\n1000.0\n88.281415\n\n\n-0.08\n1000.0\n88.281415",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#export-to-csv-format",
    "href": "docs/tutorials/simulation_and_plotting.html#export-to-csv-format",
    "title": "Simulation and Plotting",
    "section": "3.2 Export to CSV Format",
    "text": "3.2 Export to CSV Format\nWe can also export simulation results from PowerFactory to a csv file. The syntax is very simlar to the export to pandas:\n\npfres.export_to_csv()\n\n'D:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\results.csv'\n\n\nThis exports all variables from the first result object (ElmRes) found in the active study case to the directory from where the script is run. You can also specifiy a directory, a file name (default is “results”) and lists for grid objects, variables and results objects (similar to the method export_to_pandas).\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\npfres.export_to_csv(\n    file_name=\"Power of Synchronous Machine 01\",\n    list_of_results_objs=elmres_list,\n    elements=elements,\n    variables=variables,\n)\n\n'D:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\Power of Synchronous Machine 01.csv'\n\n\nThe static method plot_from_csv pf Plots class is used to plot from files of this format:\n\nfrom powfacpy.applications.plots import Plots\n\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:P1\")\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:Q1\")\nplt.grid()\n\n\n\n\n\n\n\n\nPyplot is used by default, but you can specify a different plot interface using the optional argument plot_interface.",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/getting_started.html",
    "href": "docs/tutorials/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\n\nThen import powfacpy and create an instance of class ActiveProject (with argument app). This interface class is mainly used to interact with the active project in the PowerFactory database as we will see below.\n\nfrom powfacpy.base.active_project import ActiveProject\n\n\nact_prj = ActiveProject(app)\n\nNote that pfp has an attribute app that can be used similar to the app variable we loaded from the powerfactory module.\nThe PowerFactory project used in this tutorial can be found in the powfacpy repository under *tests_input_tests.pfd*.\nHere are two ways to 1. show the PowerFactory application and 2. activate a project:\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\nact_prj.app.Show()\nact_prj.app.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\nSo where does pfp differ from the Python interface that app provides? Let’s see.\n\n1 Accessing Objects\nLet’s access an object from the PowerFactory database. When using app, we would use the methods app.GetProjectFolder, app.GetChildren or app.GetContents. Instead, we use act_prj.get_obj with the path of the object (relative to the folder of the active project) as an argument:\n\nmv_terminal = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\"\n)[0]\n\nThe [0] at the end is necessary because the method always returns a list (with one element in this case).\nNote that you can easily copy and paste the path from the data manager while selecting the object in the data tree:\n\n\n\nobject path\n\n\nact_prj.get_obj also differs in other ways from app.GetContents and app.GetCalcRelevantObjects. You can set a condition for the objects that you want to access, which is best described by an example:\n\nhv_terminals = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\",\n    condition=lambda x: x.uknom &gt; 50,\n)\n\nFirst of all, we use a wildcard (*.ElmTerm) to access all terminals in the Grid folder. The condition argument is a function that defines a certain condition the objects have to fulfill and returns a boolean value. In this case, the input argument x is an ElmTerm and x.uknom &gt; 50 gets its attribute uknom (nominal voltage) and checks whether it is larger than 50 (kV). Using this .uknom notation is equivalent to using getattr(x, \"uknom\"), which is a python method that returns an attribute of any object (also PowerFactory objects). You can also define more complex functions, such as lambda x: x.uknom &gt; 50 and x.uknom &lt; 200 to access terminals between 50 and 200 kV.\nIt is also possible to include subfolders in the search for objects:\n\nterminals = act_prj.get_obj(\n    r\"Network Model\\Network Data\\*.ElmTerm\", include_subfolders=True\n)\n\nThis will search in Network Model\\Network Data and all its subfolders (by default include_subfolders is False, be carefull as including all subfolders in the search can affect the performance).\nWhat’s also very helpful is that act_prj.get_obj throws an error if the path is incorrect and shows exactly where it fails. So\nterminals = act_prj.get_obj(r\"Network Model\\wrong_folder_name\\*.ElmTerm\")\nwill throw an error:\nPFPathError: ‘wrong_folder_name’ does not exist in ’_baseModel’\nBy default, an exception is also raised if no objects are found in the specified folder. For example:\nterminals = act_prj.get_obj(r\"Network Model\\Network Data\\wrong_object_name*\", include_subfolders=True)\nreturns\nPFPathError: ’wrong_object_name*’ does not exist in ’_baseModelData’\nThis can be turned off by setting the optional argument error_if_non_existent=False, then an empty list will be returned.\nIf you want to access objects in a folder many times and don’t want to use the whole path relative to the active project every time, you can also specifiy a parent folder where the search path starts (this can also be more performant):\n\ngrid_folder = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\"\n)[0]\n\nmv_terminal = act_prj.get_obj(\"Terminal MV\", parent_folder=grid_folder)[0]\nhv_terminal = act_prj.get_obj(\"Terminal HV 1\", parent_folder=grid_folder)[0]\n\nYou can also use brackets to call get_obj (the ActiveProject class defines a __getitem__ method that calls get_obj without optional arguments):\n\nterminals = act_prj[\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\"\n]\n\nThe get_obj command can become verbose with many keyword arguments. This can be inconvenient, for example when you have to call the method many times with the same arguments. powfacpy provides the get_object_partial method which returns a Callable. This way you can define new variations of get_obj:\n\nget_obj_subf = act_prj.get_obj_partial(include_subfolders=True)\n# This can now be used with further arguments of 'get_obj' as follows (and will always assume 'include_subfolders=True'):\nterminals = get_obj_subf(\"*.ElmTerm\", parent_folder=grid_folder)\n\nUnder the hood the partial function from the built-in functools module of Python is used (it is actually pretty simple to do the above with any Python method/function). Note that for the commonly required inclusion of subfolders in the search there is actually a separate method get_obj_including_subfolders available (another alternative for network objects in get_calc_relevant_obj as described below).\nAn alternative to act_prj.get_obj is act_prj.get_unique_obj. Use this function if you want to access a single unique object (i.e. an object that you expect to only exist once) from the database and want to avoid the [0] (which is easily forgotten).\n\nterminal_1 = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\n\nget_unique_obj will throw an error if the specified path is not attributable to a single unique object (i.e. also when two or more objects are found).\nFinally, yet another alternative for getting network objects is get_calc_relevant_obj: powfacpy wraps the GetCalcRelevenatObjects method and adds optional arguments, similar to get_obj:\n\nterminals = act_prj.get_calc_relevant_obj(\n    \"ElmTerm\", error_if_non_existent=False, includeOutOfService=0\n)\n\n\n\n2 Accessing Project Folders and Data\nThe ActiveProject class defines a number of properties to directly access relevant project folders (under the hood, the GetProjectFolder and GetDataFolder methods are used). Here are some examples (you may just type act_prj.folder and your IDE will autocomplete all the properties):\n\nact_prj.study_cases_folder  # This is a getter property returning StudyCases.IntPrjfolder\nact_prj.network_model_folder\nact_prj.zones_folder\nact_prj.variations_folder\nact_prj.operation_scenarios_folder\n# ...\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Operation Scenarios.IntPrjfolder&lt;/l1&gt;&gt;\n\n\nTo get all active grids/networks (ElmNet) use:\n\nactive_networks = act_prj.get_active_networks()\n# act_prj.app.GetCalcRelevantObjects(\".ElmNet\") also returns the summary grid in the study case which is usually not desired.\n\n\n\n3 Getting Objects from the Active Study Case\nThe native GetFromStudyCase method returns the first object found that satisfies the criteria or creates a new object in the active study case. This is a common source of errors when more than one object satisfies the criteria and this goes unnoticed (this often happens for example when users work on the same project with different language settings). You can use the powfacpy method instead which prints a warning or raises an error if the the object found is not unique:\n\nresults_obj = act_prj.get_from_study_case(\"ElmRes\", if_not_unique=\"warning\")\n\nD:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\docs\\tutorials\\..\\..\\src\\powfacpy\\base\\active_project.py:174: UserWarning: The returned *.ElmRes object is not unique in the  study case: 'Study Cases\\test_active_project_interface\\Study Case 1'. Make sure that the correct *.ElmRes object is used.\n  warn(\n\n\n\n\n4 Type Hints\nType hints are used in Python to improve the readability and code completion, but do not actually affect the excuted code (except when you do static type checking). They are often seen in function/method definitions and are preceded by a colon, e.g.:\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nThis means that the function expects two input arguments of type integer and returns an integer. powfacpy defines protocol classes for (almost) all PowerFactory classes (more than 200) from the scripting reference (with very few exceptions) and a few additional classes (such as ‘IntSite’ which is not mentioned in the scripting reference).\nIn the following example a type hint is used (‘:ElmTerm’). Your IDE will then autocomplete all attributes (methods and data) of the variable ‘terminal’:\n\nfrom powfacpy.pf_classes.protocols import ElmTerm\n\nterminal: ElmTerm = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\nterminal.uknom\n\n110.0\n\n\nAny modern IDE should autocomplete your code while writing:\n\n\n\ntype_hints\n\n\nNote that this also works with lists:\n\nterminals: list[ElmTerm] = act_prj.get_calc_relevant_obj(\"ElmTerm\")\n\n\n\n5 Setting and Getting Object Attributes\nHow about setting data in the database? You can set attributes of an object as follows:\n\nact_prj.set_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    {\"uknom\": 33, \"outserv\": 0},\n)\n\nSo with only one command we set the attributes “uknom” and “outserv” of the terminal. This saves time and is also very readable code. Note that the method set_attr accepts the path (string) but also a PowerFactory object. For example, we could also use the object mv_terminal that we loaded above:\n\nact_prj.set_attr(mv_terminal, {\"uknom\": 33, \"outserv\": 0})\n\nThis applies to many other methods in powfacpy. Loading the object only once and then using the object can be more efficient than using the path string many times.\nIf you want to get an attribute of an object, write:\n\nnominal_voltage = act_prj.get_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    \"uknom\",\n)\n\n\n# Equivalent:\nnominal_voltage = act_prj.get_attr(mv_terminal, \"uknom\")\nnominal_voltage = act_prj.get_attr(\n    \"Terminal MV\",\n    \"uknom\",\n    parent_folder=r\"Network Model\\Network Data\\test_active_project_interface\\Grid\",\n)\n\n\n\n6 Creating Objects and Directories\nIf you want to create a new object, use:\n\nfrom powfacpy.pf_class_protocols import BlkDef, IntPrjfolder\n\nnew_obj: BlkDef = act_prj.create_by_path(r\"Library\\Dynamic Models\\dummy.BlkDef\")\n\nThis will create an object of class “BlkDef” with the name “dummy” in the folder “LibraryModels”. You can also use\n\nnew_obj: BlkDef = act_prj.create_in_folder(\n    \"dummy.BlkDef\", r\"Library\\Dynamic Models\", overwrite=True\n)\n\n\n# Or equivalent:\nmodels_folder: IntPrjfolder = act_prj.get_unique_obj(r\"Library\\Dynamic Models\")\nnew_obj: BlkDef = act_prj.create_in_folder(\n    \"dummy.BlkDef\", models_folder, overwrite=True\n)\n\nwhich will overwrite the former object (this avoids that PowerFactory creates dummy(1), dummy(2), … every time the code is run). overwrite=True is the default setting.\nTo create a directory, i.e. a nested folder structure, use\n\nact_prj.create_directory(\n    r\"New Study Case\\Cases Normal Opration\", parent_folder=\"Study Cases\"\n)\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\New Study Case\\Cases Normal Opration&lt;/l1&gt;&gt;\n\n\n\n\n7 Copying Objects\nThe method copy_obj can be seen as a method that uses get_obj as a first step to access objects and then copies them to a target folder under the hood. Therefore, copy_obj shares many (optional) input arguments with get_obj to first get the objects to be copied. Additionally, a target folder is required. For example, to copy all objects from a source folder to a target folder, write\n\nsource_folder = r\"Library\\Dynamic Models\\TestDummyFolder\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nnew_copied_objects = act_prj.copy_obj(\"*\", target_folder, parent_folder=source_folder)\n\nNote that parent folder is an optional argument (used for the source), so you could also specify the full object path as the first argument instead of using * (similar to get_obj). To select certain objects from the source folder, you can use optional arguments like condition or include_subfolders, also similar to the get_obj method. The method also accepts a list of PowerFactory objects:\n\nlist_of_objects_to_copy = act_prj.get_obj(\"*\", parent_folder=source_folder)\ntarget_folder_obj = act_prj.get_unique_obj(r\"Library\\Dynamic Models\\TestCopyMultiple\")\nnew_copied_objects = act_prj.copy_obj(\n    list_of_objects_to_copy, target_folder_obj, overwrite=True\n)\n\nNote that the target folder object (instead of a path string) is used (second argument).\nIf you want to copy a single object, use copy_single_obj. You have the option to give it a new name (loc_name attribute):\n\nnew_copy = act_prj.copy_single_obj(\n    r\"Library\\Dynamic Models\\Linear_interpolation\",\n    r\"Library\\Dynamic Models\\TestCopy\",\n    new_name=\"new_dummy_name\",\n)\n\nFirst input here is the path of the object to be copied, but you can also use a PowerFactory object.\n\n\n8 Moving Objects\nThe syntax to move objects is similar to copying:\n\n# Multiple objects\nsource_folder = r\"Library\\Dynamic Models\\TestCopy\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nnew_copied_objects = act_prj.move_obj(\"*\", target_folder, parent_folder=source_folder)\n\n# Single object\nsource_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopy\"\nnew_copied_objects = act_prj.move_single_obj(\n    \"new_dummy_name\", target_folder, parent_folder=source_folder\n)\n\n\n\n9 Deleting Objects\nDeleting objects works in a similar fashion, because under the hood it uses get_obj and deletes the returned objects in the second step.\n\nact_prj.delete_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    include_subfolders=True,\n    error_if_non_existent=False,\n)\n\nAnd of course you could also use PowerFactory objects as an input:\n\nobjects_in_folder = act_prj.get_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    error_if_non_existent=False,\n)\n\nact_prj.delete_obj(objects_in_folder, error_if_non_existent=False)\n\nYou can also delete all objects in a folder:\n\nact_prj.clear_folder(\"Library\\Dynamic Models\\TestDelete\")\n\n\n\n10 Further Useful Methods\nFurther helpful methods are briefly described in the following. get_upstream_obj returns an upsream object that meets a condition (i.e. the method goes upwards in the folder hierarchy until a parent object is found that meets the condition).\nHere this is used to find the grid that contains a given object:\n\nobj = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_database_interface\\Grid\\Voltage source ctrl\\Frequency\"\n)\ngrid = act_prj.get_upstream_obj(obj, lambda x: x.loc_name == \"Grid\")\nprint(act_prj.get_path_of_object(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\n\n\nget_path_of_object returns the path of an object relative to the active project and without any class names. The user can can directly copy the returned string to the data manager to quickly find the object in the PowerFactory app.\n\n\n\nobject path\n\n\nThere are more methods to get the path of an object:\n\nprint(act_prj.get_path_of_object(grid))  # path inside project\nprint(act_prj.get_path_of_obj_with_class_names(grid))\nprint(act_prj.get_full_path_of_object(grid))  # full path in database\nprint(act_prj.get_full_path_of_object_with_class_names(grid))\nprint(act_prj.get_path_of_object_in_active_project(grid))\nprint(act_prj.get_path_of_object_in_active_project_with_class_names(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\\seberlein\\powfacpy\\powfacpy_tests_copy_where_tests_run\\Network Model\\Network Data\\test_database_interface\\Grid\n\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\n\n\n\n11 The Folder Class\nMost of the functionality described above is not limited to the folder of the active project, but can be used with any folder in the database. The class ‘Folder’ can be used with any folder. Path input arguments are then relative to that folder (and not to the active project as above, unless of course a ‘parent_folder’ is specified):\n\nfrom powfacpy.base.folder import Folder\n\nnetwork_data_folder = Folder(r\"Network Model\\Network Data\", app)\n\n\ngrid = network_data_folder.get_unique_obj(\n    \"test_active_project_interface\\Grid\"\n)  # relative to 'Network Data' folder\n\n\nprint(network_data_folder.get_path_of_object(grid))\n\ntest_active_project_interface\\Grid\n\n\nNote that ‘Folder’ instances are iterable. For example, you can use a for-loop to iterate through the (direct) children of the folder:\n\nfor object in network_data_folder:\n    print(network_data_folder.get_path_of_object(object))\n\nAreas\nBackbones\nVirtual Power Plants\nBoundaries\nCable Layouts\nCircuits\nDistribution correlations\nFeeders\nMeteo Stations\nOperators\nOwners\nPaths\nRoutes\nZones\ntest_plot_interface\nnetwork_for_elmfiles\ntest_case_studies\ntest_dyn_sim_interface\ntest_active_project_interface\ntest_network_interface\ntest_results_interface\ntest_database_interface\ntest_model_exchange_interfaces\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html",
    "href": "docs/docs/structure_of_powfacpy.html",
    "title": "Structure of powfacpy",
    "section": "",
    "text": "The structure of the source code of powfacpy (see folder src/powfacpy) is the explained in the following. At first, the basics relevant for users of powfacpy are introduced. Then some more advanced topics are elaborated for power users and contributors to the package in Section 2.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#sec-active-project",
    "href": "docs/docs/structure_of_powfacpy.html#sec-active-project",
    "title": "Structure of powfacpy",
    "section": "1.1 Active Project",
    "text": "1.1 Active Project\n\nbase/active_project.py\n\nThe class ActiveProject in base/active_project.py is the main interface to the database of PowerFactory as illustrated in the Getting Started Tutorial.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#sec-pf-classes",
    "href": "docs/docs/structure_of_powfacpy.html#sec-pf-classes",
    "title": "Structure of powfacpy",
    "section": "1.2 PowerFactory Classes",
    "text": "1.2 PowerFactory Classes\n\npf_classes/\n\nThis is a collection of interface classes that refer directly to individual classes in the PowerFactory database. The classes “inherit” (more details in Section 2) from the classes in the PowerFactory database and add further functionality. For example, the SynchronousMachine class (in pf_classes/elm/sym) has all data and functionality (as described in the python scripting reference of PowerFactory) of PowerFactory’s ElmSym class, but adds further functionality (e.g. a secure way of getting the rated apparent power, which considers the number of parallel machines).\nThe classes in the PowerFactory database can be grouped based on the first three letters and the remaining part of their names (e.g. Elm + Sym, where Elm is common to all network element classes and Sym is short for synchronous machine). This is reflected by the subfolders (elm, sta, set, etc.) which contain the interface classes for each subgroup. The files in the subfolders are named accordingly, but the full names are used for the classes in the files (e.g. sym.py in the elm folder contains the class SynchronousMachine) to distinguish the class names from the protocol classes (see below). To create an instance, an instance of the native PowerFactory class must be provided, as in the following example:\nfrom powfacpy.pf_classes.elm.sym import SynchronousMachine\nfrom powfacpy.base.active_project import ActiveProject\n\nact_prj = ActiveProject()\nsm_pf_native = act_prj.get_calc_relevant_object(\"SM 01.ElmSym\")\nsm = SynchronousMachine(sm_pf_native)\nsm.Disconnect() # Method from native PF object\nx = sm.get_averaged_internal_reactance() # Method from powfacpy.pf_classes.elm.sym\nIn addition, pf_classes/protocols.py contains protocol classes for (almost) all classes from the PowerFactory database (automatically created, see protocol_generator.py). They are used for type hints for example, as explained in the Getting Started Tutorial.\n\n\n\n\n\n\nProtocols\n\n\n\nNote that there is a protocols.py file in the root directory for compatibility with versions prior to 0.3.0. It will be deprecated and pf_classes/protocols.py should be used.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#applications",
    "href": "docs/docs/structure_of_powfacpy.html#applications",
    "title": "Structure of powfacpy",
    "section": "1.3 Applications",
    "text": "1.3 Applications\n\napplications/\n\nIn comparison to the PowerFactory classes from Section 1.2, this folder contains applications that are more complex than an interface to a single PowerFactory class. The applications are more complicated and often require multiple native PowerFactory classes. Examples are interfaces for plotting, dynamic simulation, results export, network topology analysis, study cases, etc.\nApplication classes usually have an attribute that is an instance of ActiveProject (see Section 1.1) to interact with the active project. Prior to version 0.3.0, Application classes inherited from ActiveProject instead, but this cluttered the Application classes with many methods (ActiveProject is large). Hence, it was decided that composition is the better option.\n\n\n\n\n\n\nComparison of PowerFactory classes and Applications\n\n\n\nAs a rule of thumb, any functionality that involves only one native PowerFactory class should be accommodated in an interface class in the pf_classes/ folder. Applications can make use of this functionality. This prevents too much functionality from being packed into the application classes.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#result-variables",
    "href": "docs/docs/structure_of_powfacpy.html#result-variables",
    "title": "Structure of powfacpy",
    "section": "1.4 Result Variables",
    "text": "1.4 Result Variables\n\nresult_variables.py\n\nThe file result_variables.py contains (automatically created) enumeration classes for results variables (e.g. of dynamic simulations) and it is created by executing result_variables_parser.py. The usage is explained in the Simulation and Plotting Tutorial.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#deprecated",
    "href": "docs/docs/structure_of_powfacpy.html#deprecated",
    "title": "Structure of powfacpy",
    "section": "1.5 Deprecated",
    "text": "1.5 Deprecated\n\ndeprecated/ (not shown in Figure 1)\n\nThis folder contains files used in versions prior to 0.3.0 for compatibility.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#base",
    "href": "docs/docs/structure_of_powfacpy.html#base",
    "title": "Structure of powfacpy",
    "section": "2.1 base",
    "text": "2.1 base\nThis folder contains base classes that are used in for Application and PowerFacory classes and the ActiveProject class.\n\n2.1.1 base/folder.py\nThis file contains the Folder class which provides functionality to interact with the PowerFactory database, such as getting objects and setting attributes of objects inside a folder in the PowerFactory database. To interact with PowerFactory, it holds the PowerFactory app as a class attribute.\n\n\n2.1.2 base/active_project.py\nThe file contains the ActiveProject class that inherits from the Folder class and adds functionality specific to the active project in PowerFactory. The class ActiveProjectCached can be more performant than ActiveProject as it caches the properties, but it should be used only in one project (the caching fails after a different project was activated).\n\n\n2.1.3 base/base.py\nThis file contains base classes for PowerFactory interface classes (see Section 1.2). Instances of such classes usually hold one data attribute (the native PowerFactory object). In some use cases, numerous instances will have to be created (e.g. for all terminals in a network). Therefore, it is essential that these classes access and allocate their data efficiently. This is implemented in the BaseObjectStatic class using slots.\nThe class BaseChildStatic inherits from BaseObjectStatic and adds functionality to inherit behavior from native PowerFactory objects (see Section 1.2) by overloading the methods __getattribute__ and __setattr__.\n\n\n2.1.4 base/functional.py\nThis is a functional interface to be used as a (limited) alternative to ActiveProject and Folder. Performance can be improved as there are more restrictions on the input arguments (for example, only PowerFactory objects are accepted and not their path string).",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#pf_classes",
    "href": "docs/docs/structure_of_powfacpy.html#pf_classes",
    "title": "Structure of powfacpy",
    "section": "2.2 pf_classes",
    "text": "2.2 pf_classes\nThe classes in the pf_classes folder usually overload the method __new__ with the following boilerplate code (exemplified for SynchronousMachine):\n    def __new__(cls, *args, **kwargs) -&gt; ElmSym | SynchronousMachine:\n        \"\"\"Implemented only to add type hints for the created instance.\n\n        Returns:\n            ElmSym | SynchronousMachine: New instance\n        \"\"\"\n        instance = super().__new__(cls)\n        return instance\nThe sole reason is to make type hints work.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#engineering_helpers.py",
    "href": "docs/docs/structure_of_powfacpy.html#engineering_helpers.py",
    "title": "Structure of powfacpy",
    "section": "2.3 engineering_helpers.py",
    "text": "2.3 engineering_helpers.py\nThese are generic helper functions in the electrical and power engineering domain.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#exceptions.py",
    "href": "docs/docs/structure_of_powfacpy.html#exceptions.py",
    "title": "Structure of powfacpy",
    "section": "2.4 exceptions.py",
    "text": "2.4 exceptions.py\nThis is a collection of custom exceptions of powfacpy. Custom exceptions can provide more information on what goes wrong and are easier to catch for any python code that uses powfacpy.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/overview.html",
    "href": "docs/docs/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Please use the sidebar to navigate through the documentation.\n\n\n\n Back to top",
    "crumbs": [
      "Docs",
      "Overview"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html",
    "href": "docs/docs/how_to_contribute.html",
    "title": "How to Contribute",
    "section": "",
    "text": "Contributions in the form of issues (bug reports, feature requests, etc.) and to the codebase are very welcome.\nIf you want to contribute to the codebase there are a few things to consider which are described in the following. Note that any valuable contribution is appreciated even if they do not adhere to all of the following guidelines. And if you have questions just open an issue.",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#where-should-i-add-a-new-feature",
    "href": "docs/docs/how_to_contribute.html#where-should-i-add-a-new-feature",
    "title": "How to Contribute",
    "section": "1 Where should I add a new feature?",
    "text": "1 Where should I add a new feature?\nIt is recommended to read through the description of the structure of powfacpy to select a suitable location of the new feature (usually either in the applications or the pf_classes folder).",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#should-i-add-tests",
    "href": "docs/docs/how_to_contribute.html#should-i-add-tests",
    "title": "How to Contribute",
    "section": "2 Should I add tests?",
    "text": "2 Should I add tests?\nIt is good practice to add unit tests using the pytest package. Unit tests are located in the tests folder, which has a similar folder structure as the source code. The unit tests require PowerFactory test projects which you can find under tests/tests_input/. They need to be added in the PowerFactory database to the folder specified in settings.json (attribute path to powfacpy folder in PowerFactory database). If you adapt those .pfd files for your tests, don’t forget to commit the new version.",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#how-can-i-showcase-the-functionality-of-the-feature",
    "href": "docs/docs/how_to_contribute.html#how-can-i-showcase-the-functionality-of-the-feature",
    "title": "How to Contribute",
    "section": "3 How can I showcase the functionality of the feature?",
    "text": "3 How can I showcase the functionality of the feature?\nTo expose features to a wider range of users, adding a tutorial is more effective than just adding source code. Tutorials are located in the docs/tutorials folder. Like the whole website, they are written in quarto(markdown like syntax with extended features). If you prefer working with jupyter notebooks, you can easily convert jupyter notebooks to quarto (.qmd) with the command quarto convert my_tutorial.ipynb. Finally, to make the .qmd file appear on the website, it must be added to the *_quart.yml* file in the root directory, e.g.:\nsidebar:\n- title: \"Tutorials\"\n    style: \"docked\"\n    contents:\n    - docs/tutorials/overview.qmd\n    - docs/tutorials/getting_started.qmd\n    - docs/tutorials/simulation_and_plotting.qmd\n    - docs/tutorials/study_cases.qmd\n    - docs/tutorials/my_tutorial.qmd",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/release_notes.html",
    "href": "docs/docs/release_notes.html",
    "title": "Release Notes",
    "section": "",
    "text": "Structural changes:\n\nIn this version, the structure of powfacpy has changed fundamentally\nPlease have a look at Structure of powfacpy to understand the new structure and why the restructuring was necessary\nInstead of PFBaseInterface the class ActiveProject from base/active_project should be used\nInterfaces for plotting, case study, etc. are now found under applications/.\nAll former interface classes can still be used, but their files are located in a folder called deprecated and you will get deprecation warnings\n\nThere should be few breaking changes. Some of the known are:\n\nThe labels of the result export to pandas have changed (see the tutorial)\nThe name of the method export_results_of_study_cases of the class PFStudyCases has changed to export_results_of_study_cases_to_csv\n\nblack formatter was introduced as the standard formatter for python code\nThe format of the website was changed from sphinx to quarto\nFunctionality:\n\nInterface for network topology was added\nInterfaces to several single PowerFactory classes was added (see powfacpy/pf_classes/)",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/docs/release_notes.html#v0.3.0",
    "href": "docs/docs/release_notes.html#v0.3.0",
    "title": "Release Notes",
    "section": "",
    "text": "Structural changes:\n\nIn this version, the structure of powfacpy has changed fundamentally\nPlease have a look at Structure of powfacpy to understand the new structure and why the restructuring was necessary\nInstead of PFBaseInterface the class ActiveProject from base/active_project should be used\nInterfaces for plotting, case study, etc. are now found under applications/.\nAll former interface classes can still be used, but their files are located in a folder called deprecated and you will get deprecation warnings\n\nThere should be few breaking changes. Some of the known are:\n\nThe labels of the result export to pandas have changed (see the tutorial)\nThe name of the method export_results_of_study_cases of the class PFStudyCases has changed to export_results_of_study_cases_to_csv\n\nblack formatter was introduced as the standard formatter for python code\nThe format of the website was changed from sphinx to quarto\nFunctionality:\n\nInterface for network topology was added\nInterfaces to several single PowerFactory classes was added (see powfacpy/pf_classes/)",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/index.html",
    "href": "docs/index.html",
    "title": "powfacpy",
    "section": "",
    "text": "1 Introduction\npowfacpy is a wrapper around the Python API of PowerFactory© (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory© with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory© database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\nset_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path Network Mod….\nPlotting also requires many lines with the native API (you need to add the variable to the monitored variables, create a plot page, add the curve,..). Using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\nset_active_plot(\"Active power\",\"§ PV plant\")\nplot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the Tutorials.\n\n\n2 Why use powfacpy?\nThere are a number of reasons why you should consider using powfacpy:\n\nIncrease productivity\nWrite more readable code\nAvoid running into similar problems, errors and obscurities as other users of the python interface of PowerFactory did before you\nHaving a standard way of doing things in your organization (e.g. a standard format for simulation result export)\nSteep learning curve for PowerFactory beginners (helpful tutorials)\n\n\n\n3 Installation\nUsing pip:\npip install powfacpy\n\n\n4 Contact\nsimon.eberlein@iee.fraunhofer.de\n\n\n5 Contribute\nContributions (new features, bug reports, feature requests, etc.) are very welcome on Github. IF you want to contribute to the code base, please have a look at How to contribute.\n\n\n6 About\npowfacpy is an open source package which is mainly developed at Fraunhofer IEE and not associated with DIgSILENT.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/tutorials/overview.html",
    "href": "docs/tutorials/overview.html",
    "title": "Overview",
    "section": "",
    "text": "The following tutorials illustrate the functionality of powfacpy. You can use the PowerFactory project under *tests_input_tests.pfd* to run the commands in the tutorials locally. You can follow the link to Github on the right to download the tutorials in .qmd format (quarto). If you prefer jupyter notebook format, you can convert them with quarto convert &lt;tutorial_name.qmd&gt; (assuming quarto is installed).\n\n1 Getting started\nStart here with the getting started tutorial. This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code.\n\n\n2 Dynamic Simulation and Plotting\nThe tutorial shows how to conveniently simulate and plot with a syntax similar to matplotlib. It is also depicted how to export data to pandas and csv formats and use external plotting libraries such as matplotlib.\n\n\n3 Study Cases\nThe study cases tutorial illustrate how to automatically create study cases for parameter studies.\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/study_cases.html",
    "href": "docs/tutorials/study_cases.html",
    "title": "Study Cases",
    "section": "",
    "text": "Parameter studies are organized in study cases, operation scenarios and variations in PowerFactory. This tutorials shows how to create parameter studies with ease and fully automated using the study cases interface of powfacpy.\nFirst, we activate the PowerFactory project as in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\n\n1 Simple Parameter Study\nWe use the class StudyCases. This class inherits from PFActiveProject, so all methods from that class are available. We want to create study case with various values for the active and reactive power of a load.\nFirst we set the attribute parameter_values and define a dictionary with parameter names and a list of values. Each element in the lists is used in one study case.\n\nfrom powfacpy.applications.study_cases import StudyCases\n\npfsc = StudyCases(app)\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc.parameter_values = {\n    \"p HV load\": [1,   2, 1, 2],\n    \"q HV load\": [-1, -1, 1, 1], \n}\n# fmt: on\n\nHere we have defined four study cases and in the first case p HV load equals 1 and q HV load equals -1. The parameter names must not contain *?=“,~|()! as these characters cannot be used for names of objects in PF.\nNext we connect the variables to the PF database by defining a dictionary with paths in the attribute parameter_paths using the same parameter names as keys. The paths include the attribute name (e.g. plini which is the active power of the load).\n\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\",  # This is one string split over several lines\n    \"q HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\n\nFinally we define the active grids. For now, we assume that for all cases exactly one grid is active (we look at more complicated cases later).\n\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\nNow let’s create the study cases (and corresponding operation scenarios) in a new folder named ‘Autocreated’:\n\npfsc.parent_folder_study_cases = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.study_cases_folder\n)\npfsc.parent_folder_scenarios = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.operation_scenarios_folder\n)\n# Alternatively, just use\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\npfsc.create_cases()\n\nThis creates the following study cases in the ‘Autocreated’ folder:\n\nThe names of the study cases are created according to the parameter names and their values (“_” is used instead of “=” which is not allowed in PF object names). Furthermore, the corresponding operation scenarios are created:\n\nFor more complicated case studies with further parameters, it is advisable to structure the cases in folders. We define the attribute hierarchy using a list (in this case with onl yone item) of parameter names that corresponds to folder directories.\n\npfsc.hierarchy = [\"q HV load\"]\npfsc.create_cases()\n\nNow q HV load is used for the folder names and not in the study case name.\n\nThe structure of the operation scenarios is similar.\n\n\n2 Advanced Parameter Study\nLet’s take a look at a more complex parameter study.\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc = StudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":    [1,   2, 2,  1,  1,  2,  1,  2,],\n    \"q HV load\":    [-1, -1, 1,  1,  -1, -1, 1,  1,],\n    \"control\":      [\"A\",\"A\",\"A\",\"A\",\"B\",\"B\",\"B\",\"B\"],\n}\n# fmt: on\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\plini\",\n    \"q HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n\nAn additional parameter control is defined. Note that there is no parameter path defined for this parameter. The parameter can be seen as a placeholder for the study cases structure and to do more complicated things than simply setting an attribute of a PF object later (we’ll see below).\nBy default, study cases and operation scenarios are created. If variations should be created in addition, use:\n\npfsc.add_variation_to_each_case = True\n\nThis can be necessary because some parameters, like attributes of DSL objects, are stored in variants and not in operation scenarios. Let’s again create the study cases.\n\npfsc.hierarchy = [\"control\", \"q HV load\"]\npfsc.create_cases()\n\nThis creates the following structure in the network variations (as well as in the scenarios and study cases):\n\nLet’s set further parameters, add plots (using plot interface) and simulate (using dyn. simulation interface) for each study case. The study case objects are stored in the study_cases attribute. We can iterate through the cases and set parameters depending on the previously defined control parameter.\n\nfrom powfacpy.applications.plots import Plots\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\n\npfpi = Plots(app)\npfds = DynamicSimulation(app)\ndsl_controller_obj = pfsc.act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\n\n\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    study_case_obj.Activate()\n    # Set controller parameters\n    if pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"A\":\n\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 0, \"VFlag\": 1})\n    elif pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"B\":\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 1, \"VFlag\": 0})\n    # Prepare plots\n    pfpi.clear_plot_pages()\n    pfpi.set_active_plot(\"Reactive current\", \"WPP\")\n    pfpi.plot(dsl_controller_obj, \"s:Iqcmd\")\n    # Simulate\n    pfds.initialize_and_run_sim()\n\nLet’s walk through this piece of code. The plotting and simulation interfaces are instantiated and a DSL object is assigned to be used later.\nIt is iterated through the study cases objects (and case numbers) and each study case is activated. Then the controller parameters are set. The value of the control parameter is obtained using the method get_value_of_parameter_for_case and the controller parameters are set depending on the controller type (A or B). This provides the flexibility to adjust the study cases depending on previously defined parameters in any way (e.g. set parameters, activate grids, …). And all settings are stored in the previously defined operation scenarios/variations.\nFinally, a plot is created for every case and the dynamic simulation is executed.\n\n\n3 Compare Study Cases\nIt is often required to compare the results of cases. In the following, we use the previously defined cases to compare the simulation results for cases where the parameter p HV load equals 1 (note that you may have to “Rebuild”  the plot in the upper left for PF to show it correctly):\n\n# Create a study case where results from other cases are compared in a plot\nstudy_case_comparison = pfsc.act_prj.create_by_path(\n    r\"Study Cases\\Autocreated\\Comparison.IntCase\"\n)\nstudy_case_comparison.Activate()\npfpi.clear_plot_pages()\npfpi.set_active_plot(\n    \"Reactive current controller setpoint for p HV load = 1\", \"Comparison \"\n)\ndsl_controller_obj = (\n    r\"Network Model\\Network Data\\test_case_studies\"\n    r\"\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    if pfsc.get_value_of_parameter_for_case(\"p HV load\", case_num) == 1:\n        # Get results object from respective study case\n        results_obj = pfsc.act_prj.get_unique_obj(\n            \"*.ElmRes\", parent_folder=study_case_obj\n        )\n        # Create label for plot\n        case_label = pfsc.get_case_params_value_string(\n            case_num, omitted_parameters=\"p HV load\", delimiter=\" | \", equals_sign=\"=\"\n        )\n        label = \"Iq setpoint (\" + case_label + \")\"\n        # Plot\n        pfpi.plot(dsl_controller_obj, \"s:Iqcmd\", results_obj=results_obj, label=label)\n\nThis creates a plot with legend:\n\nLet’s walk through the code. After creating a study case where the results are compared in a plot, it is again iterated through all cases. For cases where p HV load has a certain value, the result object is fetched. Next we want to create a label for the curve in the plot. We use the method get_case_params_value_string with certain options for the delimiter and the equals symbol (here we have more options than for PF object names, i.e. = and | are allowed). Moreover, the parameter p HV load is omitted because it is the same for all compared cases (i.e. 1, see condition). Further information on the variable is added to the label and the curve is finally added to the plot.\nAn alternative to iterating through all study cases is to get certain cases using the method get_study_cases:\n\nstudy_cases_p_HV_load_equals_1 = pfsc.get_study_cases({\"p HV load\": lambda x: x == 1})\nfor study_case_obj in study_cases_p_HV_load_equals_1:\n    pass\n    # do something with the specific cases\n\nget_study_cases takes a dictionary as input, where lambda functions with conditions for parameters are defined. Note that the methods get_value_of_parameter_for_case and get_case_params_value_string also work with study case objects as inputs instead of case numbers.\nA very convenient yet powerful alternative to ‘get_study_cases’ especially for complicated conditionals is ‘get_study_cases_from_string’. This method simply accepts a string which can contain complicated conditionals:\n\nstudy_cases_from_conditionals = pfsc.get_study_cases_from_string(\n    \"p HV load &gt;= 2 and (control == 'A' or q HV load != 1)\"\n)\n\nThat makes it very easy to plot and compare certain cases.\n\n\n4 Permutation\nIt is also possible to create study cases for the permutation of the parameters (i.e. all combinations). This is achieved with the method apply_permutation. Define the parameter values first (and also the hierarchy if applicable) and then call the method. Make sure that the PF application is hidden to improve the performance (if not hidden, this can take minutes and otherwise only seconds - the ‘try-finally’ block ensures that the app is always shown in the end even if an exception is thrown):\n\ntry:\n    pfsc = StudyCases(app)\n    pfsc.act_prj.app.Hide()\n    pfsc.parameter_values = {\n        \"p HV load\": [1, 2, 3],\n        \"q HV load\": [-1, 1],\n        \"control 1\": [\"A\", \"B\"],\n        \"control 2\": [\"R\", \"S\"],\n    }\n    pfsc.hierarchy = [\n        \"p HV load\",\n        \"control 1\",\n    ]\n    pfsc.apply_permutation()\n    pfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    pfsc.act_prj.app.Show()\n\napply_permutation irreversibly replaces the values in parameter_values with the permutation.\nIt may be desirable to use the permutation but omit certain combinations. These omitted combinations can be defined in a list of dictionaries and used as a keyword argument as follows (note that we clear the parent folders from the formerly created objects first):\n\ntry:\n    app.Hide()\n    omitted_combinations = [\n        {\"q HV load\": [1], \"control 2\": [\"R\"]},\n        {\"p HV load\": [2, 3], \"control 1\": \"all\"},\n    ]\n    pfsc.apply_permutation(omitted_combinations=omitted_combinations)\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    app.Show()\n\nThe first dictionary causes any combinations where “q HV load” is 1 and “control 2” is “R” to be omitted (these cases will not be created when create_cases is called). In the second dictionary, the keyword “all” is used. This means that all combinations with this parameter are omitted.\n\n\n5 Further Functionality\nThe attributes of StudyCases instances allow to set further options.\nThe study case names can be numbered consecutively setting consecutively_number_case_names.\nSometimes it is convenient to use only parameter values without the parameter names for the folder/study case names (imagine the value of a parameter is expressive enough and you don’t want to use “Controller_GridCode2012Controller” but only “GridCode2012Controller” instead). This can be achieved by adding parameters to the list of anonymous_parameters (e.g. pfsc.anonymous_parameters=[\"Controller\",\"FurtherParName\"]).\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Study Cases"
    ]
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html",
    "href": "tutorials/simulation_and_plotting.html",
    "title": "Simulation and Plotting",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nThe following tutorial introduces dynamic simulations (RMS/EMT), plotting and exporting of results (to pandas or csv) using powfacpy.\nLet’s again set up PowerFactory and create an instance of powfacpy’s Plots class. This class inherits from ActiveProject (so those methods are available). We use the ‘39-Bus New England’ example from PowerFactory (see File-&gt;Examples).\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\nfrom powfacpy.applications.plots import Plots\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\n\npfplt = Plots(app)\nstudy_case = pfplt.act_prj.activate_study_case(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\"\n)"
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "href": "tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "title": "Simulation and Plotting",
    "section": "3.1 Export to Pandas DataFrame",
    "text": "3.1 Export to Pandas DataFrame\nLet’s export dynamic simulation results to a Pandas DataFrame. We’ll hide the PowerFactory app to improve the performance.\n\ntry:\n    app.Hide()\n    pfds.act_prj.clear_elmres()\n    pfds.act_prj.add_results_variable(\n        [\n            r\"Network Model\\Network Data\\Grid\\G 01\",\n            r\"Network Model\\Network Data\\Grid\\G 02\",\n        ],\n        [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value],\n    )\n    pfds.initialize_and_run_sim()\n    df_sim_res = pfres.export_to_pandas()\nfinally:\n    app.Show()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\nGrid\\G 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nMulti index column labels are used by default. The first index is the path of the object inside the network data folder and the second index is the variable name.\nYou can also use single index column format:\n\npfres.multi_index_labels = False\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\\s:P1\nGrid\\G 01\\s:Q1\nGrid\\G 02\\s:P1\nGrid\\G 02\\s:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nIt is also possible to set the actual PF objects as labels:\n\npfres.pf_objects_in_labels = True\npfres.multi_index_labels = True\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 01.ElmSym&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 02.ElmSym&lt;/l3&gt;\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nThe column headers are the path of the objects relative to the network data folder (by default) together with the result variable name. You can change the relative path by setting the attribute pfres.truncate_paths_until (relative to active project):\n\npfres.multi_index_labels = True\npfres.pf_objects_in_labels = False\npfres.truncate_paths_until = \"Network Model\\\\Network Data\\\\Grid\\\\\"\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\nG 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\npowfacpy offers methods to easily extract results from the exported pandas DataFrame using PowerFactory objects instead of columns headers (note that changing the format of the column headers of the DataFrame after export will break this functionality):\n\nimport matplotlib.pyplot as plt\n\np_g_01 = pfres.get_simulation_results_from_dataframe(\n    df_sim_res,\n    g_01,  # accepts using PF objects of their path inside the active project)\n    RMS_bal.ElmSym.s_P1.value,\n)\np_g_01.plot(grid=True)\np_g_01.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\n\n\ntime\n\n\n\n\n\n-0.10\n1000.0\n\n\n-0.09\n1000.0\n\n\n-0.08\n1000.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s look a more complicated example where you want to examine the active and reactive power of the synchronous machines G 01 and G 02.\n\n# SM objects\nsm_objs = [\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 01\"),\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 02\"),\n]\n\n# Results variables\nsm_res_var = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\n\npfres.act_prj.clear_elmres()\npfres.act_prj.add_results_variable(sm_objs, sm_res_var)\npfdi = DynamicSimulation(app)\npfdi.initialize_and_run_sim()\n\nWe want to add a legend to the plots. As the default variable and object names might not be very descriptive, powfacpy allows to define aliases, e.g. to be used later for labels in plots:\n\npfres.variable_aliases = {\n    RMS_bal.ElmSym.s_P1.value: \"Active Power\",\n    RMS_bal.ElmSym.s_Q1.value: \"Reactive Power\",\n}  # note that RMS_bal.ElmSym.s_P1.value gives 's:P1'\n\npfres.obj_aliases = {\n    \"G 01\": \"Synch. Maschine 1 (large)\",\n    \"G 02\": \"Synch. Maschine 2\",\n}\n\nLet’s see how the variable_aliases dictionary can then be used when plotting active and reactive power of G 01 using replace_variable_aliases:\n\ndf_sim_res = pfres.export_to_pandas()\nfor var in sm_res_var:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm_objs[0], var)\n    label = pfres.replace_variable_aliases(var)\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nInstead of s:P1 or s:Q1, the replacements defined in the dictionaries above are used for the labels.\nOr in a similar fashion, using also the object_aliases to plot the reactive power of both machines:\n\nvar = RMS_bal.ElmSym.s_P1.value\nfor sm in sm_objs:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm, var)\n    label = (\n        pfres.replace_object_aliases(sm.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nHence, the dictionaries are a clean option to define aliases and reuse them anywhere in your code.\nNote that get_simulation_results_from_dataframe also accepts a list of objects (as well as a list of variables). You can easily get various time series results and then process the data using pandas (e.g. calculate mean or average):\n\nvar = RMS_bal.ElmSym.s_P1.value\nres = pfres.get_simulation_results_from_dataframe(\n    df_sim_res, sm_objs, var  # list with G 01 and G 02\n)\n\nmean = res.mean(1)  # pandas method to get mean over axis 1\nsum = res.sum(1)\n\n# Plot active power of individual SMs\nfor sm_num, sm_obj in enumerate(sm_objs):\n    label = (\n        pfres.replace_object_aliases(sm_obj.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res.iloc[:, sm_num], label=label)\n\n# Plot mean and sum\nlabel_sms = \", \".join([pfres.replace_object_aliases(sm.loc_name) for sm in sm_objs])\nlabel = \"MEAN of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(mean, label=label)\nlabel = \"SUM of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(sum, label=label)\nplt.legend(loc=\"lower center\", bbox_to_anchor=(0.5, 1.0))\nplt.grid()\n\n\n\n\n\n\n\n\nNote that the same code block can be used with other result variables (e.g. reactive power) just by changing the var assignment in the first line.\nBy default, export_to_pandas exports all monitored variables of the first ElmRes object found in the active study case. Alternatively, selections of network elements and the respective variables as well as results objects (ElmRes) can be specified as lists:\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\ndf_sim_res = pfres.export_to_pandas(\n    list_of_results_objs=elmres_list, elements=elements, variables=variables\n)\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n\n\n-0.09\n1000.0\n88.281415\n\n\n-0.08\n1000.0\n88.281415"
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html#export-to-csv-format",
    "href": "tutorials/simulation_and_plotting.html#export-to-csv-format",
    "title": "Simulation and Plotting",
    "section": "3.2 Export to CSV Format",
    "text": "3.2 Export to CSV Format\nWe can also export simulation results from PowerFactory to a csv file. The syntax is very simlar to the export to pandas:\n\npfres.export_to_csv()\n\n'd:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\results.csv'\n\n\nThis exports all variables from the first result object (ElmRes) found in the active study case to the directory from where the script is run. You can also specifiy a directory, a file name (default is “results”) and lists for grid objects, variables and results objects (similar to the method export_to_pandas).\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\npfres.export_to_csv(\n    file_name=\"Power of Synchronous Machine 01\",\n    list_of_results_objs=elmres_list,\n    elements=elements,\n    variables=variables,\n)\n\n'd:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\Power of Synchronous Machine 01.csv'\n\n\nThe static method plot_from_csv pf Plots class is used to plot from files of this format:\n\nfrom powfacpy.applications.plots import Plots\n\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:P1\")\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:Q1\")\nplt.grid()\n\n\n\n\n\n\n\n\nPyplot is used by default, but you can specify a different plot interface using the optional argument plot_interface."
  }
]