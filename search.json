[
  {
    "objectID": "tutorials/study_cases.html",
    "href": "tutorials/study_cases.html",
    "title": "Study Cases",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nParameter studies are organized in study cases, operation scenarios and variations in PowerFactory. This tutorials shows how to create parameter studies with ease and fully automated using the study cases interface of powfacpy.\nFirst, we activate the PowerFactory project as in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\n\n1 Simple Parameter Study\nWe use the class StudyCases. This class inherits from PFActiveProject, so all methods from that class are available. We want to create study case with various values for the active and reactive power of a load.\nFirst we set the attribute parameter_values and define a dictionary with parameter names and a list of values. Each element in the lists is used in one study case.\n\nfrom powfacpy.applications.study_cases import StudyCases\n\npfsc = StudyCases(app)\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc.parameter_values = {\n    \"p HV load\": [1,   2, 1, 2],\n    \"q HV load\": [-1, -1, 1, 1], \n}\n# fmt: on\n\nHere we have defined four study cases and in the first case p HV load equals 1 and q HV load equals -1. The parameter names must not contain *?=“,~|()! as these characters cannot be used for names of objects in PF.\nNext we connect the variables to the PF database by defining a dictionary with paths in the attribute parameter_paths using the same parameter names as keys. The paths include the attribute name (e.g. plini which is the active power of the load).\n\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\",  # This is one string split over several lines\n    \"q HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\n\nFinally we define the active grids. For now, we assume that for all cases exactly one grid is active (we look at more complicated cases later).\n\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\nNow let’s create the study cases (and corresponding operation scenarios) in a new folder named ‘Autocreated’:\n\npfsc.parent_folder_study_cases = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.study_cases_folder\n)\npfsc.parent_folder_scenarios = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.operation_scenarios_folder\n)\n# Alternatively, just use\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\npfsc.create_cases()\n\nThis creates the following study cases in the ‘Autocreated’ folder:\n\nThe names of the study cases are created according to the parameter names and their values (“_” is used instead of “=” which is not allowed in PF object names). Furthermore, the corresponding operation scenarios are created:\n\nFor more complicated case studies with further parameters, it is advisable to structure the cases in folders. We define the attribute hierarchy using a list (in this case with onl yone item) of parameter names that corresponds to folder directories.\n\npfsc.hierarchy = [\"q HV load\"]\npfsc.create_cases()\n\nNow q HV load is used for the folder names and not in the study case name.\n\nThe structure of the operation scenarios is similar.\n\n\n2 Advanced Parameter Study\nLet’s take a look at a more complex parameter study.\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc = StudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":    [1,   2, 2,  1,  1,  2,  1,  2,],\n    \"q HV load\":    [-1, -1, 1,  1,  -1, -1, 1,  1,],\n    \"control\":      [\"A\",\"A\",\"A\",\"A\",\"B\",\"B\",\"B\",\"B\"],\n}\n# fmt: on\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\plini\",\n    \"q HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n\nAn additional parameter control is defined. Note that there is no parameter path defined for this parameter. The parameter can be seen as a placeholder for the study cases structure and to do more complicated things than simply setting an attribute of a PF object later (we’ll see below).\nBy default, study cases and operation scenarios are created. If variations should be created in addition, use:\n\npfsc.add_variation_to_each_case = True\n\nThis can be necessary because some parameters, like attributes of DSL objects, are stored in variants and not in operation scenarios. Let’s again create the study cases.\n\npfsc.hierarchy = [\"control\", \"q HV load\"]\npfsc.create_cases()\n\nThis creates the following structure in the network variations (as well as in the scenarios and study cases):\n\nLet’s set further parameters, add plots (using plot interface) and simulate (using dyn. simulation interface) for each study case. The study case objects are stored in the study_cases attribute. We can iterate through the cases and set parameters depending on the previously defined control parameter.\n\nfrom powfacpy.applications.plots import Plots\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\n\npfpi = Plots(app)\npfds = DynamicSimulation(app)\ndsl_controller_obj = pfsc.act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\n\n\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    study_case_obj.Activate()\n    # Set controller parameters\n    if pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"A\":\n\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 0, \"VFlag\": 1})\n    elif pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"B\":\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 1, \"VFlag\": 0})\n    # Prepare plots\n    pfpi.clear_plot_pages()\n    pfpi.set_active_plot(\"Reactive current\", \"WPP\")\n    pfpi.plot(dsl_controller_obj, \"s:Iqcmd\")\n    # Simulate\n    pfds.initialize_and_run_sim()\n\nLet’s walk through this piece of code. The plotting and simulation interfaces are instantiated and a DSL object is assigned to be used later.\nIt is iterated through the study cases objects (and case numbers) and each study case is activated. Then the controller parameters are set. The value of the control parameter is obtained using the method get_value_of_parameter_for_case and the controller parameters are set depending on the controller type (A or B). This provides the flexibility to adjust the study cases depending on previously defined parameters in any way (e.g. set parameters, activate grids, …). And all settings are stored in the previously defined operation scenarios/variations.\nFinally, a plot is created for every case and the dynamic simulation is executed.\n\n\n3 Compare Study Cases\nIt is often required to compare the results of cases. In the following, we use the previously defined cases to compare the simulation results for cases where the parameter p HV load equals 1 (note that you may have to “Rebuild”  the plot in the upper left for PF to show it correctly):\n\n# Create a study case where results from other cases are compared in a plot\nstudy_case_comparison = pfsc.act_prj.create_by_path(\n    r\"Study Cases\\Autocreated\\Comparison.IntCase\"\n)\nstudy_case_comparison.Activate()\npfpi.clear_plot_pages()\npfpi.set_active_plot(\n    \"Reactive current controller setpoint for p HV load = 1\", \"Comparison \"\n)\ndsl_controller_obj = (\n    r\"Network Model\\Network Data\\test_case_studies\"\n    r\"\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    if pfsc.get_value_of_parameter_for_case(\"p HV load\", case_num) == 1:\n        # Get results object from respective study case\n        results_obj = pfsc.act_prj.get_unique_obj(\n            \"*.ElmRes\", parent_folder=study_case_obj\n        )\n        # Create label for plot\n        case_label = pfsc.get_case_params_value_string(\n            case_num, omitted_parameters=\"p HV load\", delimiter=\" | \", equals_sign=\"=\"\n        )\n        label = \"Iq setpoint (\" + case_label + \")\"\n        # Plot\n        pfpi.plot(dsl_controller_obj, \"s:Iqcmd\", results_obj=results_obj, label=label)\n\nThis creates a plot with legend:\n\nLet’s walk through the code. After creating a study case where the results are compared in a plot, it is again iterated through all cases. For cases where p HV load has a certain value, the result object is fetched. Next we want to create a label for the curve in the plot. We use the method get_case_params_value_string with certain options for the delimiter and the equals symbol (here we have more options than for PF object names, i.e. = and | are allowed). Moreover, the parameter p HV load is omitted because it is the same for all compared cases (i.e. 1, see condition). Further information on the variable is added to the label and the curve is finally added to the plot.\nAn alternative to iterating through all study cases is to get certain cases using the method get_study_cases:\n\nstudy_cases_p_HV_load_equals_1 = pfsc.get_study_cases({\"p HV load\": lambda x: x == 1})\nfor study_case_obj in study_cases_p_HV_load_equals_1:\n    pass\n    # do something with the specific cases\n\nget_study_cases takes a dictionary as input, where lambda functions with conditions for parameters are defined. Note that the methods get_value_of_parameter_for_case and get_case_params_value_string also work with study case objects as inputs instead of case numbers.\nA very convenient yet powerful alternative to ‘get_study_cases’ especially for complicated conditionals is ‘get_study_cases_from_string’. This method simply accepts a string which can contain complicated conditionals:\n\nstudy_cases_from_conditionals = pfsc.get_study_cases_from_string(\n    \"p HV load &gt;= 2 and (control == 'A' or q HV load != 1)\"\n)\n\nThat makes it very easy to plot and compare certain cases.\n\n\n4 Permutation\nIt is also possible to create study cases for the permutation of the parameters (i.e. all combinations). This is achieved with the method apply_permutation. Define the parameter values first (and also the hierarchy if applicable) and then call the method. Make sure that the PF application is hidden to improve the performance (if not hidden, this can take minutes and otherwise only seconds - the ‘try-finally’ block ensures that the app is always shown in the end even if an exception is thrown):\n\ntry:\n    pfsc = StudyCases(app)\n    pfsc.act_prj.app.Hide()\n    pfsc.parameter_values = {\n        \"p HV load\": [1, 2, 3],\n        \"q HV load\": [-1, 1],\n        \"control 1\": [\"A\", \"B\"],\n        \"control 2\": [\"R\", \"S\"],\n    }\n    pfsc.hierarchy = [\n        \"p HV load\",\n        \"control 1\",\n    ]\n    pfsc.apply_permutation()\n    pfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    pfsc.act_prj.app.Show()\n\napply_permutation irreversibly replaces the values in parameter_values with the permutation.\nIt may be desirable to use the permutation but omit certain combinations. These omitted combinations can be defined in a list of dictionaries and used as a keyword argument as follows (note that we clear the parent folders from the formerly created objects first):\n\ntry:\n    app.Hide()\n    omitted_combinations = [\n        {\"q HV load\": [1], \"control 2\": [\"R\"]},\n        {\"p HV load\": [2, 3], \"control 1\": \"all\"},\n    ]\n    pfsc.apply_permutation(omitted_combinations=omitted_combinations)\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    app.Show()\n\nThe first dictionary causes any combinations where “q HV load” is 1 and “control 2” is “R” to be omitted (these cases will not be created when create_cases is called). In the second dictionary, the keyword “all” is used. This means that all combinations with this parameter are omitted.\n\n\n5 Further Functionality\nThe attributes of StudyCases instances allow to set further options.\nThe study case names can be numbered consecutively setting consecutively_number_case_names.\nSometimes it is convenient to use only parameter values without the parameter names for the folder/study case names (imagine the value of a parameter is expressive enough and you don’t want to use “Controller_GridCode2012Controller” but only “GridCode2012Controller” instead). This can be achieved by adding parameters to the list of anonymous_parameters (e.g. pfsc.anonymous_parameters=[\"Controller\",\"FurtherParName\"]).\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials/getting_started.html",
    "href": "tutorials/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nThis tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\n\nThen import powfacpy and create an instance of class PFActiveProject (with argument app). This interface class is mainly used to interact with the active project in the PowerFactory database as we will see below.\n\nfrom powfacpy.base.active_project import ActiveProject\n\npfp = ActiveProject(app)\n\nNote that pfp has an attribute app that can be used similar to the app variable we loaded from the powerfactory module.\nThe PowerFactory project used in this tutorial can be found in the powfacpy repository under *tests_input_tests.pfd*.\nHere are two ways to 1. show the PowerFactory application and 2. activate a project:\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\npfp.app.Show()\npfp.app.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\nSo where does pfp differ from the Python interface that app provides? Let’s see.\n\n1 Accessing Objects\nLet’s access an object from the PowerFactory database. When using app, we would use the methods app.GetProjectFolder, app.GetChildren or app.GetContents. Instead, we use pfp.get_obj with the path of the object (relative to the folder of the active project) as an argument:\n\nmv_terminal = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\"\n)[0]\n\nThe [0] at the end is necessary because the method always returns a list (with one element in this case).\nNote that you can easily copy and paste the path from the data manager while selecting the object in the data tree:\n\n\n\nobject path\n\n\npfp.get_obj also differs in other ways from app.GetContents and app.GetCalcRelevantObjects. You can set a condition for the objects that you want to access, which is best described by an example:\n\nhv_terminals = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\",\n    condition=lambda x: x.uknom &gt; 50,\n)\n\nFirst of all, we use a wildcard (*.ElmTerm) to access all terminals in the Grid folder. The condition argument is a function that defines a certain condition the objects have to fulfill and returns a boolean value. In this case, the input argument x is an ElmTerm and x.uknom &gt; 50 gets its attribute uknom (nominal voltage) and checks whether it is larger than 50 (kV). Using this .uknom notation is equivalent to using getattr(x, \"uknom\"), which is a python method that returns an attribute of any object (also PowerFactory objects). You can also define more complex functions, such as lambda x: x.uknom &gt; 50 and x.uknom &lt; 200 to access terminals between 50 and 200 kV.\nIt is also possible to include subfolders in the search for objects:\n\nterminals = pfp.get_obj(\n    r\"Network Model\\Network Data\\*.ElmTerm\", include_subfolders=True\n)\n\nThis will search in Network Model\\Network Data and all its subfolders (by default include_subfolders is False, be carefull as including all subfolders in the search can affect the performance).\nWhat’s also very helpful is that pfp.get_obj throws an error if the path is incorrect and shows exactly where it fails. So\nterminals = pfp.get_obj(r\"Network Model\\wrong_folder_name\\*.ElmTerm\")\nwill throw an error:\nPFPathError: ‘wrong_folder_name’ does not exist in ’_baseModel’\nBy default, an exception is also raised if no objects are found in the specified folder. For example:\nterminals = pfp.get_obj(r\"Network Model\\Network Data\\wrong_object_name*\", include_subfolders=True)\nreturns\nPFPathError: ’wrong_object_name*’ does not exist in ’_baseModelData’\nThis can be turned off by setting the optional argument error_if_non_existent=False, then an empty list will be returned.\nIf you want to access objects in a folder many times and don’t want to use the whole path relative to the active project every time, you can also specifiy a parent folder where the search path starts (this can also be more performant):\n\ngrid_folder = pfp.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\"\n)[0]\n\nmv_terminal = pfp.get_obj(\"Terminal MV\", parent_folder=grid_folder)[0]\nhv_terminal = pfp.get_obj(\"Terminal HV 1\", parent_folder=grid_folder)[0]\n\nYou can also use brackets to call get_obj (the PFActiveProject class defines a __getitem__ method that calls get_obj without optional arguments):\n\nterminals = pfp[\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\"\n]\n\nThe get_obj command can become verbose with many keyword arguments. This can be inconvenient, for example when you have to call the method many times with the same arguments. powfacpy provides the get_object_partial method which returns a Callable. This way you can define new variations of get_obj:\n\nget_obj_subf = pfp.get_obj_partial(include_subfolders=True)\n# This can now be used with further arguments of 'get_obj' as follows (and will always assume 'include_subfolders=True'):\nterminals = get_obj_subf(\"*.ElmTerm\", parent_folder=grid_folder)\n\nUnder the hood the partial function from the built-in functools module of Python is used (it is actually pretty simple to do the above with any Python method/function). Note that for the commonly required inclusion of subfolders in the search there is actually a separate method get_obj_including_subfolders available (another alternative for network objects in get_calc_relevant_obj as described below).\nAn alternative to pfp.get_obj is pfp.get_unique_obj. Use this function if you want to access a single unique object (i.e. an object that you expect to only exist once) from the database and want to avoid the [0] (which is easily forgotten).\n\nterminal_1 = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\n\nget_unique_obj will throw an error if the specified path is not attributable to a single unique object (i.e. also when two or more objects are found).\nFinally, yet another alternative for getting network objects is get_calc_relevant_obj: powfacpy wraps the GetCalcRelevenatObjects method and adds optional arguments, similar to get_obj:\n\nterminals = pfp.get_calc_relevant_obj(\n    \"ElmTerm\", error_if_non_existent=False, includeOutOfService=0\n)\n\n\n\n2 Accessing Project Folders and Data\nThe PFActiveProject class defines a number of properties to directly access relevant project folders (under the hood, the GetProjectFolder and GetDataFolder methods are used). Here are some examples (you may just type pfp.folder and your IDE will autocomplete all the properties):\n\npfp.study_cases_folder  # This is a getter property returning StudyCases.IntPrjfolder\npfp.network_model_folder\npfp.zones_folder\npfp.variations_folder\npfp.operation_scenarios_folder\n# ...\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Operation Scenarios.IntPrjfolder&lt;/l1&gt;&gt;\n\n\nTo get all active grids/networks (ElmNet) use:\n\nactive_networks = pfp.get_active_networks()\n# pfp.app.GetCalcRelevantObjects(\".ElmNet\") also returns the summary grid in the study case which is usually not desired.\n\n\n\n3 Getting Objects from the Active Study Case\nThe native GetFromStudyCase method returns the first object found that satisfies the criteria or creates a new object in the active study case. This is a common source of errors when more than one object satisfies the criteria and this goes unnoticed (this often happens for example when users work on the same project with different language settings). You can use the powfacpy method instead which prints a warning or raises an error if the the object found is not unique:\n\nresults_obj = pfp.get_from_study_case(\"ElmRes\", if_not_unique=\"warning\")\n\nd:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\docs\\tutorials\\..\\..\\src\\powfacpy\\base\\active_project.py:173: UserWarning: The returned *.ElmRes object is not unique in the  study case: 'Study Cases\\test_active_project_interface\\Study Case 1'. Make sure that the correct *.ElmRes object is used.\n  warn(\n\n\n\n\n4 Type Hints\nType hints are used in Python to improve the readability and code completion, but do not actually affect the excuted code (except when you do static type checking). They are often seen in function/method definitions and are preceded by a colon, e.g.:\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nThis means that the function expects two input arguments of type integer and returns an integer. powfacpy defines protocol classes for (almost) all PowerFactory classes (more than 200) from the scripting reference (with very few exceptions) and a few additional classes (such as ‘IntSite’ which is not mentioned in the scripting reference).\nIn the following example a type hint is used (‘:ElmTerm’). Your IDE will then autocomplete all attributes (methods and data) of the variable ‘terminal’:\n\nfrom powfacpy.pf_class_protocols import ElmTerm\n\nterminal: ElmTerm = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\nterminal.uknom\n\n110.0\n\n\nAny modern IDE should autocomplete your code while writing:\n\n\n\ntype_hints\n\n\nNote that this also works with lists:\n\nterminals: list[ElmTerm] = pfp.get_calc_relevant_obj(\"ElmTerm\")\n\n\n\n5 Setting and Getting Object Attributes\nHow about setting data in the database? You can set attributes of an object as follows:\n\npfp.set_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    {\"uknom\": 33, \"outserv\": 0},\n)\n\nSo with only one command we set the attributes “uknom” and “outserv” of the terminal. This saves time and is also very readable code. Note that the method set_attr accepts the path (string) but also a PowerFactory object. For example, we could also use the object mv_terminal that we loaded above:\n\npfp.set_attr(mv_terminal, {\"uknom\": 33, \"outserv\": 0})\n\nThis applies to many other methods in powfacpy. Loading the object only once and then using the object can be more efficient than using the path string many times.\nIf you want to get an attribute of an object, write:\n\nnominal_voltage = pfp.get_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    \"uknom\",\n)\n\n\n# Equivalent:\nnominal_voltage = pfp.get_attr(mv_terminal, \"uknom\")\nnominal_voltage = pfp.get_attr(\n    \"Terminal MV\",\n    \"uknom\",\n    parent_folder=r\"Network Model\\Network Data\\test_active_project_interface\\Grid\",\n)\n\n\n\n6 Creating Objects and Directories\nIf you want to create a new object, use:\n\nfrom powfacpy.pf_class_protocols import BlkDef, IntPrjfolder\n\nnew_obj: BlkDef = pfp.create_by_path(r\"Library\\Dynamic Models\\dummy.BlkDef\")\n\nThis will create an object of class “BlkDef” with the name “dummy” in the folder “LibraryModels”. You can also use\n\nnew_obj: BlkDef = pfp.create_in_folder(\n    \"dummy.BlkDef\", r\"Library\\Dynamic Models\", overwrite=True\n)\n\n\n# Or equivalent:\nmodels_folder: IntPrjfolder = pfp.get_unique_obj(r\"Library\\Dynamic Models\")\nnew_obj: BlkDef = pfp.create_in_folder(\"dummy.BlkDef\", models_folder, overwrite=True)\n\nwhich will overwrite the former object (this avoids that PowerFactory creates dummy(1), dummy(2), … every time the code is run). overwrite=True is the default setting.\nTo create a directory, i.e. a nested folder structure, use\n\npfp.create_directory(\n    r\"New Study Case\\Cases Normal Opration\", parent_folder=\"Study Cases\"\n)\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\New Study Case\\Cases Normal Opration&lt;/l1&gt;&gt;\n\n\n\n\n7 Copying Objects\nThe method copy_obj can be seen as a method that uses get_obj as a first step to access objects and then copies them to a target folder under the hood. Therefore, copy_obj shares many (optional) input arguments with get_obj to first get the objects to be copied. Additionally, a target folder is required. For example, to copy all objects from a source folder to a target folder, write\n\nsource_folder = r\"Library\\Dynamic Models\\TestDummyFolder\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nnew_copied_objects = pfp.copy_obj(\"*\", target_folder, parent_folder=source_folder)\n\nNote that parent folder is an optional argument (used for the source), so you could also specify the full object path as the first argument instead of using * (similar to get_obj). To select certain objects from the source folder, you can use optional arguments like condition or include_subfolders, also similar to the get_obj method. The method also accepts a list of PowerFactory objects:\n\nlist_of_objects_to_copy = pfp.get_obj(\"*\", parent_folder=source_folder)\ntarget_folder_obj = pfp.get_unique_obj(r\"Library\\Dynamic Models\\TestCopyMultiple\")\nnew_copied_objects = pfp.copy_obj(\n    list_of_objects_to_copy, target_folder_obj, overwrite=True\n)\n\nNote that the target folder object (instead of a path string) is used (second argument).\nIf you want to copy a single object, use copy_single_obj. You have the option to give it a new name (loc_name attribute):\n\nnew_copy = pfp.copy_single_obj(\n    r\"Library\\Dynamic Models\\Linear_interpolation\",\n    r\"Library\\Dynamic Models\\TestCopy\",\n    new_name=\"new_dummy_name\",\n)\n\nFirst input here is the path of the object to be copied, but you can also use a PowerFactory object.\n\n\n8 Deleting Objects\nDeleting objects works in a similar fashion, because under the hood it uses get_obj and deletes the returned objects in the second step.\n\npfp.delete_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    include_subfolders=True,\n    error_if_non_existent=False,\n)\n\nAnd of course you could also use PowerFactory objects as an input:\n\nobjects_in_folder = pfp.get_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    error_if_non_existent=False,\n)\n\npfp.delete_obj(objects_in_folder, error_if_non_existent=False)\n\nYou can also delete all objects in a folder:\n\npfp.clear_folder(\"Library\\Dynamic Models\\TestDelete\")\n\n\n\n9 Further Useful Methods\nFurther helpful methods are briefly described in the following. get_upstream_obj returns an upsream object that meets a condition (i.e. the method goes upwards in the folder hierarchy until a parent object is found that meets the condition).\nHere this is used to find the grid that contains a given object:\n\nobj = pfp.get_unique_obj(\n    r\"Network Model\\Network Data\\test_database_interface\\Grid\\Voltage source ctrl\\Frequency\"\n)\ngrid = pfp.get_upstream_obj(obj, lambda x: x.loc_name == \"Grid\")\nprint(pfp.get_path_of_object(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\n\n\nget_path_of_object returns the path of an object relative to the active project and without any class names. The user can can directly copy the returned string to the data manager to quickly find the object in the PowerFactory app.\n\n\n\nobject path\n\n\nThere are more methods to get the path of an object:\n\nprint(pfp.get_path_of_object(grid))  # path inside project\nprint(pfp.get_path_of_obj_with_class_names(grid))\nprint(pfp.get_full_path_of_object(grid))  # full path in database\nprint(pfp.get_full_path_of_object_with_class_names(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\\seberlein\\powfacpy\\powfacpy_tests_copy_where_tests_run\\Network Model\\Network Data\\test_database_interface\\Grid\n\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\n\n\n\n10 The Folder Class\nMost of the functionality described above is not limited to the folder of the active project, but can be used with any folder in the database. The class ‘Folder’ can be used with any folder. Path input arguments are then relative to that folder (and not to the active project as above, unless of course a ‘parent_folder’ is specified):\n\nfrom powfacpy.base.folder import Folder\n\nnetwork_data_folder = Folder(r\"Network Model\\Network Data\", app)\n\n\ngrid = network_data_folder.get_unique_obj(\n    \"test_active_project_interface\\Grid\"\n)  # relative to 'Network Data' folder\n\n\nprint(network_data_folder.get_path_of_object(grid))\n\ntest_active_project_interface\\Grid\n\n\nNote that ‘Folder’ instances are iterable. For example, you can use a for-loop to iterate through the (direct) children of the folder:\n\nfor object in network_data_folder:\n    print(network_data_folder.get_path_of_object(object))\n\nAreas\nBackbones\nVirtual Power Plants\nBoundaries\nCable Layouts\nCircuits\nDistribution correlations\nFeeders\nMeteo Stations\nOperators\nOwners\nPaths\nRoutes\nZones\ntest_plot_interface\nnetwork_for_elmfiles\ntest_case_studies\ntest_dyn_sim_interface\ntest_active_project_interface\ntest_network_interface\ntest_results_interface\ntest_database_interface\ntest_model_exchange_interfaces\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/tutorials/topology_and_groupings.html",
    "href": "docs/tutorials/topology_and_groupings.html",
    "title": "Topology and Groupings",
    "section": "",
    "text": "This tutorial focuses on network topologies, specifically the organization of network elements into boundaries, zones and areas. The main topics covered include:\n\nCreating and using boundaries\nCreating and using zones\nCreating and using areas\nAdditional useful methods of powfacpy for groupings (boundaries, areas, zones)\n\nFirst, we activate the PowerFactory project of the IEEE 39 bus system example, create a copy of a stable study case and activate it.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\nfrom powfacpy.base.active_project import ActiveProject\nfrom powfacpy.pf_classes.protocols import PFApp\n\napp = powerfactory.GetApplication()\n\npf_app: PFApp = powerfactory.GetApplication()\nact_prj = ActiveProject(pf_app)\nact_prj.app.Show()\nact_prj.app.ActivateProject(\n    \"powfacpy\\\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\nstudy_case = act_prj.copy_single_obj(\"Study Cases\\\\2.3 Simulation Fault Bus 31 Stable\", \"Study Cases\", new_name=\"Topology tutorial\")\nstudy_case.Activate()\nact_prj.create_variation(\"Topology tutorial\")\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Variations.IntPrjfolder\\Topology tutorial.IntScheme&lt;/l1&gt;&gt;\n\n\nThere are various classes to group network objects in PowerFactory including - areas (ElmArea), - zones (ElmZone), - boundaries (ElmBoundary).\nAreas and zones are very similar. One of their disadvantages is that it is not possible for one network element to be part of more than one area/zone. Boundaries on the other hand are more flexible and there is no such restriction, i.e. one element can be included in more than one boundary. Note also that the zone/area classes provide a method to define a boundary (DefineBoundary) that includes their internal elements. More information can be found in the PowerFactory manual in the chapter on Grouping Objects.\nWe will examine an example in which the terminals of the IEEE 39 bus system are categorized into several regions. Each terminal is assigned to a specific region. These regions have been preselected based on coherency identification, as referenced in @khalilDynamicCoherencyIdentification2016. The configuration includes one large region and several smaller regions, as detailed in the following list of elements.\n\ncoherent_regions_terminals = [\n    [\n        \"Bus 02\",\n        \"Bus 03\",\n        \"Bus 04\",\n        \"Bus 05\",\n        \"Bus 06\",\n        \"Bus 07\",\n        \"Bus 08\",\n        \"Bus 10\",\n        \"Bus 11\",\n        \"Bus 12\",\n        \"Bus 13\",\n        \"Bus 14\",\n        \"Bus 15\",\n        \"Bus 16\",\n        \"Bus 17\",\n        \"Bus 18\",\n        \"Bus 19\",\n        \"Bus 20\",\n        \"Bus 21\",\n        \"Bus 22\",\n        \"Bus 23\",\n        \"Bus 24\",\n        \"Bus 25\",\n        \"Bus 26\",\n        \"Bus 27\",\n        \"Bus 28\",\n        \"Bus 29\",\n        \"Bus 32\",\n        \"Bus 33\",\n        \"Bus 34\",\n        \"Bus 35\",\n        \"Bus 37\",\n        \"Bus 38\",\n    ],\n    [\"Bus 01\", \"Bus 09\", \"Bus 39\"],\n    [\"Bus 31\"],\n    [\"Bus 36\"],\n    [\"Bus 30\"],\n]\n\n\n1 Boundaries\nWe will use the Topology class of powfacpy to create the regions. The lists with terminal names in coherent_regions_terminals assigned above are iterated and the method create_boundary_using_intermediate_zone is used, which creates a boundary by creating a zone in an intermediate step (first creating a zone is a convenient way to create a boundary). The method allows to exclude elements. In the example below, all loads (ElmLod) are excluded from the boundaries.\n\nfrom powfacpy.applications.topology import Topology\nfrom powfacpy.pf_classes.elm.boundary import Boundary\n\ntry:\n    app.Hide()\n    act_prj.clear_folder(act_prj.boundaries_folder)\n    topo = Topology()\n    boundaries: list[Boundary] = []\n    for n, terminals in enumerate(coherent_regions_terminals):\n        terminal_objs = [act_prj.get_calc_relevant_obj(term + \".ElmTerm\")[0] for term in terminals]\n        boundary = topo.create_boundary_using_intermediate_zone(\n            \"Region \" + str(n+1),\n            terminal_objs,\n            exclude_node_elms=lambda x: x.GetClassName() == \"ElmLod\",\n            color=n+2,\n        )\n        boundaries.append(Boundary(boundary))\nfinally:\n    app.Show()\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that the method create_boundary_using_intermediate_zone might change existing zones in the network model if their elements are included in the boundary (because elements can only be part of one zone). To avoid this use ‘create_boundary_without_changing_initial_zones’ instead.\n\n\nThe objects of class Boundary are stored in the boundaries list in the loop above. The Boundary class of powfacpy offers some convenient methods, for example to visualize the interior of (all) boundaries in the single line diagram.\n\nfrom powfacpy.applications.plots import Plots\nfrom os import getcwd\n\npf_plt = Plots(app)\npf_plt.set_active_graphics_page(\"Grid\")\nboundary_1 = boundaries[0]\nboundary_1.show_boundary_interior_regions_in_network_graphic()\n\nThe regions are now illustrated in the single line diagram. Apparently, loads are excluded from the interior of the boundaries. \nWe will now crate plots showing the active and reactive power exchange of the boundaries as well as the frequencies of the terminals.\n\nfrom powfacpy.result_variables import ResVar\n\nRMS_BAL = ResVar.RMS_Bal\n\ntry:\n    app.Hide()\n    pf_plt.clear_plot_pages()\n    for n, boundary in enumerate(boundaries):\n        pf_plt.set_active_plot(\"Active power\", \"Boundaries\")\n        pf_plt.plot(boundary.obj, \n                    boundary.get_P_exchange_res_var_rms_bal())\n        pf_plt.set_active_plot(\"Reactive power\", \"Boundaries\")\n        pf_plt.plot(boundary.obj,  \n                    boundary.get_Q_exchange_res_var_rms_bal())\n        \n        pf_plt.set_active_plot(\"Frequency\", \"Terminal frequencies\")\n        for term in coherent_regions_terminals[n]:\n            terminal_obj = act_prj.get_calc_relevant_obj(term + \".ElmTerm\")[0]\n            pf_plt.plot(terminal_obj, RMS_BAL.ElmTerm.m_fehz.value, color=n+2)\nfinally:\n    app.Show()            \n\nExecuting an RMS simulation gives the following results. As shown in the frequency plot, the frequencies at coherent terminals oscillate in phase.\n\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\npfds = DynamicSimulation(app)\npfds.initialize_and_run_sim(param_simulation={\"tstop\": 10})\n\n\n\n\npower-exchange-regions\n\n\n\n\n\nfrequencies-coherent-terminals\n\n\n\n\n2 Zones\nThe topology class also allows to create zones. For example a zone for the first region in coherent_regions_terminals can be created as follows:\n\nfrom powfacpy.pf_classes.elm.zone import Zone\n\nterminal_objs_of_region_1 = [act_prj.get_calc_relevant_obj(term+\".ElmTerm\")[0] for term in coherent_regions_terminals[0]]\nzone_obj = topo.create_zone(\"Region 1\", terminal_objs_of_region_1)\n\nThe Zone class of powfacpy can then be used to display zones in the single line diagram.\n\nzone_1 = Zone(zone_obj)\nzone_1.show_zones_in_network_graphic()\n\n\n\n3 Areas\nThe ElmArea class of PowerFactory is very similar to the ElmZone class and so is the Area class of powfacpy compared to the Zone class.\n\nfrom powfacpy.pf_classes.elm.area import Area\n\narea_obj = topo.create_area(\"Region 1\", terminal_objs_of_region_1)\narea_1 = Area(zone_obj)\narea_1.show_areas_in_network_graphic()\n\n\n\n4 Common Methods of Grouping Classes\nClasses of powfacpy that group objects (like Boundary, Zone and Area) have common methods which are defined in the abstract base class GroupingBase. Here are some examples using the zone and boundary instances created above.\n\ntry:\n    app.Hide()\n    \n    # All internal elements\n    elms = boundary_1.get_all_internal_elms()\n    elms = zone_1.get_all_internal_elms()\n\n    # Get internal elements with condition\n    elms = boundary_1.get_internal_elms(condition=lambda x: x.GetClassName()==\"ElmTerm\" and x.uknom &gt; 300)\n    elms = zone_1.get_internal_elms(condition=lambda x: x.GetClassName()==\"ElmTerm\" and x.uknom &gt; 300)\n    \n    # Get internal elements of class\n    elms = boundary_1.get_internal_elms_of_class(\"ElmLne\")\n    elms = zone_1.get_internal_elms_of_class(\"ElmLne\")\n    \n    # Get results variable for active power exchange in RMS simulations\n    p_res_var = boundary_1.get_P_exchange_res_var_rms_bal()\n    p_res_var = zone_1.get_P_exchange_res_var_rms_bal()\n    \nfinally:\n    app.Show()\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Topology and Groupings"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html",
    "href": "docs/tutorials/simulation_and_plotting.html",
    "title": "Simulation and Plotting",
    "section": "",
    "text": "The following tutorial introduces dynamic simulations (RMS/EMT), plotting and exporting of results (to pandas or csv) using powfacpy.\nLet’s again set up PowerFactory and create an instance of powfacpy’s Plots class. This class inherits from ActiveProject (so those methods are available). We use the ‘39-Bus New England’ example from PowerFactory (see File-&gt;Examples).\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2025 SP3\\Python\\3.13\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\nfrom powfacpy.applications.plots import Plots\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\n\npfplt = Plots(app)\nstudy_case = pfplt.act_prj.activate_study_case(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\"\n)",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#plotting-simulation-results",
    "href": "docs/tutorials/simulation_and_plotting.html#plotting-simulation-results",
    "title": "Simulation and Plotting",
    "section": "1.1 Plotting Simulation Results",
    "text": "1.1 Plotting Simulation Results\nIn PowerFactory, monitored result variables (to be later plotted or exported) need to be specified before the simulation. The easiest way to plot results using powfacpy is to simply use the method plot before the simulation, which automaticallly adds a variable to the monitored variables and plots it as soon as the simulation has run.\nFirst, we set the active plot (starting from a clean graphics board by clearing all plot pages).\n\npfplt.clear_plot_pages()  # Start from a clean graphics board\npfplt.set_active_plot(\"Plot 1\", \"Plot page 1\")\n\nThe method set_active_plot takes the name of the plot and the name of the page of the plot as input arguments. If the plot (or the page) does not exist, it is created. If there should be several plots on one page, the method is called several times with the same page name but different plot name (e.g. pfplt.set_active_plot(\"Plot 2\", \"Plot page 1\")).\nAll plot commmands are applied to the active plot. We can now add curves to the plot.\n\n# Curve of variable \"s:P1\"\npfplt.plot(r\"Network Model\\Network Data\\Grid\\G 01\", \"s:P1\")\n\n# Curve of variable \"s:Q1\"\ng_01 = pfplt.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 01\")\nresults_obj = pfplt.act_prj.get_unique_obj(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\\All calculations\"\n)\n# Plot with keyword arguments\npfplt.plot(\n    g_01,  # obj or str\n    \"s:Q1\",\n    linestyle=3,\n    linewidth=200,\n    color=5,\n    label=\"Reactive power setpoint\",\n    results_obj=results_obj,\n)\n\nNOTE: If the plot is not shown properly in PowerFactory, click on refresh  and rescale .\nThe method plot takes the PF object (or its path) and a results variable as first and second input. Furthermore, keyword arguments can be specified as shown for the second curve.\nNow we can execute a dynamic simulation using the DynamicSimulations interface class.\n\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\n\npfds = DynamicSimulation(app)\npfds.initialize_sim({\"iopt_sim\": \"rms\"})\npfds.run_sim({\"tstop\": 0.5})\n\nThe two methods initialize and run the simulation. Paramters for the ComInc object (initialization) and the ComSim (run simulation) can be specified in a dictionary. If no parameters need to be set, one can also use:\n\npfds.initialize_and_run_sim()\n\nIn some cases, it might be more convenient to add the result variable first, then simulate and finally specifiy the plot:\n\npfplt.clear_curves()\npfds.initialize_sim({\"iopt_sim\": \"rms\"})\npfds.act_prj.add_results_variable(g_01, \"s:P1\")\npfds.run_sim()\npfplt.plot_monitored_variables(g_01, \"s:P1\")\n\nSo the method add_results_variable is used to add variables to the monitored vaiables to later export or plot them.\npowfacpy offers more functionality that are helpful in this context. The ResVar class offers enumeration subclasses for results variables of various simulation types (e.g. RMS balanced/unbalanced, EMT, load flow balanced/unbalanced). The names of PowerFactory result variables can be cryptic. The enumeration classes offer an easy way to get the names and also their short description (just hover over s_P1 in RMS_bal.ElmSym.s_P1 in the cell below). Code completion in your IDE helps you find the variable you want without having to look it up in PowerFactory. The syntax is\nsimulation_type.class_name.variable_name.value\ne.g.\n\nRMS_bal.ElmSym.s_P1.value\nRMS_bal.ElmSym.m_Psum_bus1.value .\n\nIn the variable name, colons (“:”) are replaced by underscores (“_“) to comply with python naming restrictions. The value at the end is required to get the name string of the variable. It is assumed that you set RMS_bal = ResVar.RMS_Bal as in the cell below.\nAdditionally, create_dyn_sim_event in the cell below creates an event, here we add a parameter event.\n\nfrom powfacpy.result_variables import ResVar\n\nRMS_bal = ResVar.RMS_Bal  # we focus on balanced RMS simulation here\n\npfplt.clear_curves()\npfds.initialize_sim({\"iopt_sim\": \"rms\"})\npfds.act_prj.add_results_variable(g_01, RMS_bal.ElmSym.s_P1.value)\npfds.create_dyn_sim_event(\n    \"Set_turbine_power_of_g01.EvtParam\",\n    {\"p_target\": g_01, \"variable\": \"pt\", \"value\": \"0.5\", \"time\": 0},\n)\npfds.run_sim()\npfplt.plot_monitored_variables(g_01, RMS_bal.ElmSym.s_P1.value)\n\nSometimes we have created plots in one study case and want to have those plots also in another study case. This can be achieved by copying the graphics board content (or parts of it) from one study case to another:\n\nstudy_case_1 = pfplt.act_prj.get_unique_obj(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\"\n)\nstudy_case_2 = pfplt.act_prj.get_unique_obj(\n    r\"Study Cases\\2.2 Simulation Fault Bus 16 Unstable\"\n)\n\npfplt.copy_graphics_board_content(study_case_1, study_case_2, \"*.GrpPage\")\n\nThis copies all plot pages (class GrpPage) of Study Case 1 to Study Case 2. The target study case argument can also be a list of cases. Or we can use the method copy_graphics_board_content_to_all_study_cases to target all study cases or all cases in a certain folder.",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#plotting-from-pandas-dataframe",
    "href": "docs/tutorials/simulation_and_plotting.html#plotting-from-pandas-dataframe",
    "title": "Simulation and Plotting",
    "section": "1.2 Plotting from Pandas DataFrame",
    "text": "1.2 Plotting from Pandas DataFrame\nIf you want to display external data in a plot inside PowerFactory, you can use the method plot_from_pandas_using_comtrade. This method takes a pandas DataFrame as input and plots it in the active plot. The DataFrame must have a time index and columns for each variable to be plotted.\nLet’s create such a DataFrame.\n\nimport pandas as pd\nimport numpy as np\n\nt = np.arange(0, 0.1, 0.0005)\ndf = pd.DataFrame(    {\n        \"time\": t,\n        \"voltage\": np.sin(2*np.pi*50*t)+ 1j*np.sin(2*np.pi*50*t),\n        \"current\": np.cos(2*np.pi*50*t),})\ndf.set_index(\"time\", inplace=True)\ndf.plot()\n\nD:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\venv\\Lib\\site-packages\\matplotlib\\cbook.py:1719: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\nD:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\venv\\Lib\\site-packages\\matplotlib\\cbook.py:1355: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n\n\n\n\n\n\n\n\n\nAnd we plot the two variables inside PowerFactory.\n\nfrom pandas.api.types import is_complex_dtype\n\npfplt.set_active_plot(\"Test from df\", \"Test from df\")\nfor col in df.columns:\n    if is_complex_dtype(df[col]):\n        df[col + \"_real\"] = np.real(df[col])\n        df[col + \"_imag\"] = np.imag(df[col]) \n        del df[col]\npfplt.plot_from_pandas_using_comtrade(df)\n\n'C:\\\\Users\\\\seberlein\\\\AppData\\\\Local\\\\DIgSILENT\\\\PowerFactory 2025 SP3\\\\Workspace.C64O8EL\\\\projectdata\\\\34156546\\\\comtrade_files\\\\Test from df_Test from df_0'",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "href": "docs/tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "title": "Simulation and Plotting",
    "section": "3.1 Export to Pandas DataFrame",
    "text": "3.1 Export to Pandas DataFrame\nLet’s export dynamic simulation results to a Pandas DataFrame. We’ll hide the PowerFactory app to improve the performance.\n\ntry:\n    app.Hide()\n    pfds.act_prj.clear_elmres()\n    pfds.act_prj.add_results_variable(\n        [\n            r\"Network Model\\Network Data\\Grid\\G 01\",\n            r\"Network Model\\Network Data\\Grid\\G 02\",\n        ],\n        [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value],\n    )\n    pfds.initialize_and_run_sim()\n    df_sim_res = pfres.export_to_pandas()\nfinally:\n    app.Show()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\nGrid\\G 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nMulti index column labels are used by default. The first index is the path of the object inside the network data folder and the second index is the variable name.\nYou can also use single index column format:\n\npfres.multi_index_labels = False\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\\s:P1\nGrid\\G 01\\s:Q1\nGrid\\G 02\\s:P1\nGrid\\G 02\\s:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nIt is also possible to set the actual PF objects as labels:\n\npfres.pf_objects_in_labels = True\npfres.multi_index_labels = True\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 01.ElmSym&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 02.ElmSym&lt;/l3&gt;\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nThe column headers are the path of the objects relative to the network data folder (by default) together with the result variable name. You can change the relative path by setting the attribute pfres.truncate_paths_until (relative to active project):\n\npfres.multi_index_labels = True\npfres.pf_objects_in_labels = False\npfres.truncate_paths_until = \"Network Model\\\\Network Data\\\\Grid\\\\\"\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\nG 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\npowfacpy offers methods to easily extract results from the exported pandas DataFrame using PowerFactory objects instead of columns headers (note that changing the format of the column headers of the DataFrame after export will break this functionality):\n\nimport matplotlib.pyplot as plt\n\np_g_01 = pfres.get_simulation_results_from_dataframe(\n    df_sim_res,\n    g_01,  # accepts using PF objects or their path inside the active project)\n    RMS_bal.ElmSym.s_P1.value,\n)\np_g_01.plot(grid=True)\nplt.legend()\np_g_01.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\n\n\ntime\n\n\n\n\n\n-0.10\n1000.0\n\n\n-0.09\n1000.0\n\n\n-0.08\n1000.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s look a more complicated example where you want to examine the active and reactive power of the synchronous machines G 01 and G 02.\n\n# SM objects\nsm_objs = [\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 01\"),\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 02\"),\n]\n\n# Results variables\nsm_res_var = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\n\npfres.act_prj.clear_elmres()\npfres.act_prj.add_results_variable(sm_objs, sm_res_var)\npfdi = DynamicSimulation(app)\npfdi.initialize_and_run_sim()\n\nWe want to add a legend to the plots. As the default variable and object names might not be very descriptive, powfacpy allows to define aliases, e.g. to be used later for labels in plots:\n\npfres.variable_aliases = {\n    RMS_bal.ElmSym.s_P1.value: \"Active Power\",\n    RMS_bal.ElmSym.s_Q1.value: \"Reactive Power\",\n}  # note that RMS_bal.ElmSym.s_P1.value gives 's:P1'\n\npfres.obj_aliases = {\n    \"G 01\": \"Synch. Maschine 1 (large)\",\n    \"G 02\": \"Synch. Maschine 2\",\n}\n\nLet’s see how the variable_aliases dictionary can then be used when plotting active and reactive power of G 01 using replace_variable_aliases:\n\ndf_sim_res = pfres.export_to_pandas()\nfor var in sm_res_var:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm_objs[0], var)\n    label = pfres.replace_variable_aliases(var)\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nInstead of s:P1 or s:Q1, the replacements defined in the dictionaries above are used for the labels.\nOr in a similar fashion, using also the object_aliases to plot the reactive power of both machines:\n\nvar = RMS_bal.ElmSym.s_P1.value\nfor sm in sm_objs:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm, var)\n    label = (\n        pfres.replace_object_aliases(sm.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nHence, the dictionaries are a clean option to define aliases and reuse them anywhere in your code.\nNote that get_simulation_results_from_dataframe also accepts a list of objects (as well as a list of variables). You can easily get various time series results and then process the data using pandas (e.g. calculate mean or average):\n\nvar = RMS_bal.ElmSym.s_P1.value\nres = pfres.get_simulation_results_from_dataframe(\n    df_sim_res, sm_objs, var  # list with G 01 and G 02\n)\n\nmean = res.mean(1)  # pandas method to get mean over axis 1\nsum = res.sum(1)\n\n# Plot active power of individual SMs\nfor sm_num, sm_obj in enumerate(sm_objs):\n    label = (\n        pfres.replace_object_aliases(sm_obj.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res.iloc[:, sm_num], label=label)\n\n# Plot mean and sum\nlabel_sms = \", \".join([pfres.replace_object_aliases(sm.loc_name) for sm in sm_objs])\nlabel = \"MEAN of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(mean, label=label)\nlabel = \"SUM of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(sum, label=label)\nplt.legend(loc=\"lower center\", bbox_to_anchor=(0.5, 1.0))\nplt.grid()\n\n\n\n\n\n\n\n\nNote that the same code block can be used with other result variables (e.g. reactive power) just by changing the var assignment in the first line.\nBy default, export_to_pandas exports all monitored variables of the first ElmRes object found in the active study case. Alternatively, selections of network elements and the respective variables as well as results objects (ElmRes) can be specified as lists:\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\ndf_sim_res = pfres.export_to_pandas(\n    list_of_results_objs=elmres_list, elements=elements, variables=variables\n)\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n\n\n-0.09\n1000.0\n88.281415\n\n\n-0.08\n1000.0\n88.281415\n\n\n\n\n\n\n\nAnother helpful method to make your exported data more descriptive is get_result_variable_description:\n\npfres.get_result_variable_description(sm_objs[0], RMS_bal.ElmSym.s_P1.value, simulation_type=\"RMS_Bal\")\n\n'MW, OUT, Positive-sequence, active power continuous, double'\n\n\nThis returns the variable description provided by PowerFactory and can be used in labels as well.\nYou can also extract variable descriptions for all columns of the results DataFrame and format the dictionary with the json package:\n\nimport json\n\nclasses_and_vars_descriptions = (\n    pfres.get_result_variables_descriptions_from_dataframe(\n        df_sim_res, simulation_type=\"RMS_Bal\"\n    )\n)\nprint(json.dumps(classes_and_vars_descriptions, indent=2))\n\n{\n  \"ElmSym (Synchronous Machine)\": {\n    \"s:P1\": \"MW, OUT, Positive-sequence, active power continuous, double\",\n    \"s:Q1\": \"Mvar, OUT, Positive-sequence, reactive power, continuous, double\"\n  }\n}\n\n\nThe descriptions can help users less familiar with PowerFactory understand the exported simulation results.",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/simulation_and_plotting.html#export-to-csv-format",
    "href": "docs/tutorials/simulation_and_plotting.html#export-to-csv-format",
    "title": "Simulation and Plotting",
    "section": "3.2 Export to CSV Format",
    "text": "3.2 Export to CSV Format\nWe can also export simulation results from PowerFactory to a csv file. The syntax is very simlar to the export to pandas:\n\npfres.export_to_csv()\n\n'D:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\results.csv'\n\n\nThis exports all variables from the first result object (ElmRes) found in the active study case to the directory from where the script is run. You can also specifiy a directory, a file name (default is “results”) and lists for grid objects, variables and results objects (similar to the method export_to_pandas).\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\npfres.export_to_csv(\n    file_name=\"Power of Synchronous Machine 01\",\n    list_of_results_objs=elmres_list,\n    elements=elements,\n    variables=variables,\n)\n\n'D:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\Power of Synchronous Machine 01.csv'\n\n\nThe static method plot_from_csv pf Plots class is used to plot from files of this format:\n\nfrom powfacpy.applications.plots import Plots\n\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:P1\")\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:Q1\")\nplt.grid()\n\n&lt;&gt;:3: SyntaxWarning: invalid escape sequence '\\s'\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\s'\n&lt;&gt;:3: SyntaxWarning: invalid escape sequence '\\s'\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\s'\nC:\\Users\\seberlein\\AppData\\Local\\Temp\\ipykernel_26964\\1073379661.py:3: SyntaxWarning: invalid escape sequence '\\s'\n  plot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:P1\")\nC:\\Users\\seberlein\\AppData\\Local\\Temp\\ipykernel_26964\\1073379661.py:4: SyntaxWarning: invalid escape sequence '\\s'\n  plot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:Q1\")\n\n\n\n\n\n\n\n\n\nPyplot is used by default, but you can specify a different plot interface using the optional argument plot_interface.",
    "crumbs": [
      "Tutorials",
      "Simulation and Plotting"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html",
    "title": "Network Matrices and Pandapower Interface",
    "section": "",
    "text": "This tutorial shows how to access network matrices (such as the admittance matrix of the load flow Jacobian). PowerFactory does not allow this access directly, so the dataset is first exported to the pandapower format. The matrices can then be extracted from this format.\nYou can learn more from the pandapower documentation:",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#imports-and-project-activation",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#imports-and-project-activation",
    "title": "Network Matrices and Pandapower Interface",
    "section": "1 Imports and Project Activation",
    "text": "1 Imports and Project Activation\nFirst we import some packages and activate the PowerFactory project from which we want to export the dataset (the IEEE 39 bus system example) and get the network matrices.\n\nimport os\n\nimport numpy as np\nfrom icecream import ic\nimport pandas as pd\nimport pandapower as pp\n\nfrom powfacpy.base.active_project import ActiveProject\nfrom powfacpy.pf_classes.protocols import PFApp\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2025 SP3\\Python\\3.13\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\n\npf_app: PFApp = powerfactory.GetApplication()\nact_prj = ActiveProject(pf_app)\nact_prj.app.Show()\nact_prj.app.ActivateProject(\n    \"powfacpy\\\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\nact_prj.activate_study_case(\"Study Cases\\\\2.1 Simulation Fault Bus 16 Stable\")\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\2.1 Simulation Fault Bus 16 Stable.IntCase&lt;/l1&gt;&gt;",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#export-dataset-to-pandapower",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#export-dataset-to-pandapower",
    "title": "Network Matrices and Pandapower Interface",
    "section": "2 Export Dataset to Pandapower",
    "text": "2 Export Dataset to Pandapower\nThe dataset can be exported to pandapower format using the pf_project_to_pandapower function. It requires the PowerFactory app and the path to the project as inpit arguments.\n\nfrom powfacpy.applications.pandapower_interface import PandapowerInterface\n\ntry:\n    act_prj.app.Hide()\n    ppi = PandapowerInterface(app)\n    net = ppi.pf_project_to_pandapower()\nfinally:\n    act_prj.app.Show()\nnet\n\nThis pandapower network includes the following parameter tables:\n   - bus (39 elements)\n   - load (19 elements)\n   - gen (9 elements)\n   - switch (92 elements)\n   - ext_grid (1 element)\n   - line (34 elements)\n   - trafo (12 elements)\n and the following results tables:\n   - res_bus (39 elements)\n   - res_line (34 elements)\n   - res_trafo (12 elements)\n   - res_ext_grid (1 element)\n   - res_load (19 elements)\n   - res_gen (9 elements)\n   - res_switch (92 elements)\n\n\nnet gives an overview of the exported network components and result tables (pandapower result format). PandaPower is based on pandas dataframes. You can query for example the data of the buses using:\n\nnet.bus\n\n\n\n\n\n\n\n\nname\nvn_kv\ntype\nzone\nin_service\ngeo\ndescription\nsubstat\nfolder_id\nequipment\nsernum\nchr_name\n\n\n\n\n0\nBus 08\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n1\nBus 07\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n2\nBus 05\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n3\nBus 04\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n4\nBus 06\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n5\nBus 31\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n6\nBus 11\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n7\nBus 12\n138.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n8\nBus 10\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n9\nBus 32\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n10\nBus 13\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n11\nBus 14\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n12\nBus 15\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n13\nBus 37\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n14\nBus 17\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n15\nBus 27\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n16\nBus 18\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n17\nBus 03\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n18\nBus 26\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n19\nBus 28\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n20\nBus 25\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n21\nBus 29\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n22\nBus 38\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n23\nBus 30\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n24\nBus 02\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n25\nBus 01\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n26\nBus 39\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n27\nBus 09\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n28\nBus 36\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n29\nBus 23\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n30\nBus 22\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n31\nBus 35\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n32\nBus 19\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n33\nBus 20\n230.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n34\nBus 33\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n35\nBus 24\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n36\nBus 34\n16.5\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n37\nBus 21\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n38\nBus 16\n345.0\nb\nGrid\nTrue\n{\"coordinates\":[0.0,0.0], \"type\":\"Point\"}\nGrid\n\nGrid\n\n\n\n\n\n\n\n\n\n\nNote that the name column is filled with the loc_name attributes of the PowerFactory objects. name can be used as a mapping to the respective PowerFactory object only if the loc_name of all objects of a certain class are unique (e.g. no ElmTerm instances have the same loc_name). The Database interface can be used to enumerate equivalent names of calculation relevant objects in the PowerFactory database.\n\nfrom powfacpy.applications.database import Database\n\ntry:\n    act_prj.app.Hide()\n    dbi = Database(app)\n    dbi.make_loc_name_unique()\n    net = ppi.pf_project_to_pandapower()\nfinally:\n    act_prj.app.Show()\n\nTo test whether the exported dataset is feasible, we can run a power flow using pandapower:\n\npp.runpp(net)\n\nnumba cannot be imported and numba functions are disabled.\nProbably the execution is slow.\nPlease install numba to gain a massive speedup.\n(or if you prefer slow execution, set the flag numba=False to avoid this warning!)\n\n\nThe following shows how to access the results for a certain bus.\n\nbus_name = \"Bus 05\"\nindex_of_element = net.bus[net.bus[\"name\"] == bus_name].index[0]\nnet.res_bus.iloc[index_of_element]\n\nvm_pu        1.005311\nva_degree   -8.611863\np_mw         0.000000\nq_mvar       0.000000\nName: 2, dtype: float64",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#network-matrices",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#network-matrices",
    "title": "Network Matrices and Pandapower Interface",
    "section": "3 Network Matrices",
    "text": "3 Network Matrices\n\n3.1 Admittance Matrix\nWe can no extract the Ybus (i.e admittance) matrix. By default, the returned numpy matrix is sparse, so we create a dense matrix for printing.\n\nYb = ppi.get_Ybus_matrix(net)\n\nprint(Yb)\n\n[[ 26.84540295-332.03038228j -18.76172734+215.75984428j\n   -6.34517667 +88.83248222j ...   0.          +0.j\n    0.          +0.j           0.          +0.j        ]\n [-18.76172734+215.75984428j  25.82055168-323.99513559j\n    0.          +0.j         ...   0.          +0.j\n    0.          +0.j           0.          +0.j        ]\n [ -6.34517667 +88.83248222j   0.          +0.j\n   40.62074723-549.00640737j ...   0.          +0.j\n    0.          +0.j           0.          +0.j        ]\n ...\n [  0.          +0.j           0.          +0.j\n    0.          +0.j         ...   2.74613638 -54.92271706j\n    0.          +0.j           0.          +0.j        ]\n [  0.          +0.j           0.          +0.j\n    0.          +0.j         ...   0.          +0.j\n    8.44256311-145.01095393j  -4.37421432 +73.8148601j ]\n [  0.          +0.j           0.          +0.j\n    0.          +0.j         ...   0.          +0.j\n   -4.37421432 +73.8148601j   36.02583738-510.89377228j]]\n\n\nThe base apparent power is net._ppc[\"baseMVA\"].\n\nnet._ppc[\"baseMVA\"]\n\n100.0\n\n\nThis does not provide any information about the corresponding nodes of the rows and columns. The function get_Ybus_frame provides this information.\n\ndf = ppi.get_Ybus_frame(net)\ndf\n\n\n\n\n\n\n\n\nBus 08\nBus 07\nBus 05\nBus 04\nBus 06\nBus 31\nBus 11\nBus 12\nBus 10\nBus 32\n...\nBus 23\nBus 22\nBus 35\nBus 19\nBus 20\nBus 33\nBus 24\nBus 34\nBus 21\nBus 16\n\n\n\n\nBus 08\n26.845403-332.030382j\n-18.761727+215.759844j\n-6.345177+ 88.832482j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 07\n-18.761727+215.759844j\n25.820552-323.995136j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-7.058824+108.235291j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 05\n-6.345177+ 88.832482j\n0.000000+ 0.000000j\n40.620747-549.006407j\n-4.863813+ 77.821008j\n-29.411758+382.352917j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 04\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.863813+ 77.821008j\n12.507556-201.817511j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 06\n0.000000+ 0.000000j\n-7.058824+108.235291j\n-29.411758+382.352917j\n0.000000+ 0.000000j\n46.805737-649.040329j\n0.000000+37.383178j\n-10.335155+121.068943j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 31\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 37.383178j\n0.000000-37.383178j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 11\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-10.335155+121.068943j\n0.000000+ 0.000000j\n32.622254-374.452477j\n-0.839376+22.820532j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 12\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-0.839376+ 22.820532j\n1.678752-45.641064j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 10\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n42.895446-507.854976j\n0.000000+46.728972j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 32\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 46.728972j\n0.000000-46.728972j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 13\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-0.839376+22.820532j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 14\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.788984+ 77.222383j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 15\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-10.093079+105.416621j\n\n\nBus 37\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 17\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.782937+111.668756j\n\n\nBus 27\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 18\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 03\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.854758+ 46.774120j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 26\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 28\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 25\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 29\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 38\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 30\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 02\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 01\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 39\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 09\n-1.738499+ 27.438056j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 36\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-0.675593+ 36.752279j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 23\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n8.949527-168.972606j\n-6.485084+103.761341j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-1.788850+ 28.458985j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 22\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-6.485084+103.761341j\n10.553433-243.181896j\n0.000000+68.224461j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.068349+ 71.196094j\n0.000000+ 0.000000j\n\n\nBus 35\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 68.224461j\n0.000000-68.224461j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 19\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n10.874921-184.781649j\n-3.458741+ 68.186611j\n-3.236561+65.655932j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.179618+ 50.939107j\n\n\nBus 20\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-3.458741+ 68.186611j\n6.204878-123.109328j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.746136+54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 33\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-3.236561+ 65.655932j\n0.000000+ 0.000000j\n3.236561-65.655932j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 24\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-1.788850+ 28.458985j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n10.384839-197.513413j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.595989+169.054429j\n\n\nBus 34\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.746136+ 54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n2.746136-54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\nBus 21\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n-4.068349+ 71.196094j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n8.442563-145.010954j\n-4.374214+ 73.814860j\n\n\nBus 16\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.179618+ 50.939107j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.595989+169.054429j\n0.000000+ 0.000000j\n-4.374214+ 73.814860j\n36.025837-510.893772j\n\n\n\n\n39 rows × 39 columns\n\n\n\nThe names in the labels correspond to the loc_name attributes of the PowerFactory objects. Provided that the names are unique, we can also replace them with the actual PowerFactory objects (this can be more convenient to query data, but printing the frame is ugly because the full path is used in the labels) using the PandasInterface of powfacpy.\n\nfrom powfacpy.applications.pandas_interface import PandasInterface\n\npdi = PandasInterface(app)\n\ndf = pdi.replace_loc_name_with_pf_objects_in_labels(\n    df, \"ElmTerm\", index_and_column_labels_are_equal=True\n)\ndf\n\n\n\n\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 08.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 07.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 05.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 04.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 06.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 31.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 11.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 12.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 10.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 32.ElmTerm&lt;/l3&gt;\n...\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 23.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 22.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 35.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 19.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 20.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 33.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 24.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 34.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 21.ElmTerm&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 16.ElmTerm&lt;/l3&gt;\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 08.ElmTerm&lt;/l3&gt;\n26.845403-332.030382j\n-18.761727+215.759844j\n-6.345177+ 88.832482j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 07.ElmTerm&lt;/l3&gt;\n-18.761727+215.759844j\n25.820552-323.995136j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-7.058824+108.235291j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 05.ElmTerm&lt;/l3&gt;\n-6.345177+ 88.832482j\n0.000000+ 0.000000j\n40.620747-549.006407j\n-4.863813+ 77.821008j\n-29.411758+382.352917j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 04.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.863813+ 77.821008j\n12.507556-201.817511j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 06.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n-7.058824+108.235291j\n-29.411758+382.352917j\n0.000000+ 0.000000j\n46.805737-649.040329j\n0.000000+37.383178j\n-10.335155+121.068943j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 31.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 37.383178j\n0.000000-37.383178j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 11.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-10.335155+121.068943j\n0.000000+ 0.000000j\n32.622254-374.452477j\n-0.839376+22.820532j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 12.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-0.839376+ 22.820532j\n1.678752-45.641064j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 10.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n42.895446-507.854976j\n0.000000+46.728972j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 32.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 46.728972j\n0.000000-46.728972j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 13.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-0.839376+22.820532j\n-21.447723+230.563002j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 14.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.788984+ 77.222383j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 15.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-10.093079+105.416621j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 37.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 17.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.782937+111.668756j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 27.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 18.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 03.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.854758+ 46.774120j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 26.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 28.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 25.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 29.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 38.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 30.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 02.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 01.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 39.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 09.ElmTerm&lt;/l3&gt;\n-1.738499+ 27.438056j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 36.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-0.675593+ 36.752279j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 23.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n8.949527-168.972606j\n-6.485084+103.761341j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-1.788850+ 28.458985j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 22.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-6.485084+103.761341j\n10.553433-243.181896j\n0.000000+68.224461j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.068349+ 71.196094j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 35.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 68.224461j\n0.000000-68.224461j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 19.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n10.874921-184.781649j\n-3.458741+ 68.186611j\n-3.236561+65.655932j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.179618+ 50.939107j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 20.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-3.458741+ 68.186611j\n6.204878-123.109328j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.746136+54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 33.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-3.236561+ 65.655932j\n0.000000+ 0.000000j\n3.236561-65.655932j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 24.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n-1.788850+ 28.458985j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n10.384839-197.513413j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.595989+169.054429j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 34.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-2.746136+ 54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n2.746136-54.922717j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 21.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n-4.068349+ 71.196094j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n8.442563-145.010954j\n-4.374214+ 73.814860j\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\Bus 16.ElmTerm&lt;/l3&gt;\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n...\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-4.179618+ 50.939107j\n0.000000+ 0.000000j\n0.000000+ 0.000000j\n-8.595989+169.054429j\n0.000000+ 0.000000j\n-4.374214+ 73.814860j\n36.025837-510.893772j\n\n\n\n\n39 rows × 39 columns\n\n\n\n\n\n3.2 Connectivity (Adjacency) Matrix\nThe connectivity matrix (also called adjacency matrix) is a symmetric matrix that has entries \\(1\\) (or True) for connected nodes and \\(0\\) (or False) for nodes that are not connected.\n\nppi.get_connectivity_frame(net)\n\n\n\n\n\n\n\n\nBus 08\nBus 07\nBus 05\nBus 04\nBus 06\nBus 31\nBus 11\nBus 12\nBus 10\nBus 32\n...\nBus 23\nBus 22\nBus 35\nBus 19\nBus 20\nBus 33\nBus 24\nBus 34\nBus 21\nBus 16\n\n\n\n\nBus 08\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 07\n1\n1\n0\n0\n1\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 05\n1\n0\n1\n1\n1\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 04\n0\n0\n1\n1\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 06\n0\n1\n1\n0\n1\n1\n1\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 31\n0\n0\n0\n0\n1\n1\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 11\n0\n0\n0\n0\n1\n0\n1\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 12\n0\n0\n0\n0\n0\n0\n1\n1\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 10\n0\n0\n0\n0\n0\n0\n1\n0\n1\n1\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 32\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 13\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 14\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 15\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\nBus 37\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 17\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\nBus 27\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 18\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 03\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 26\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 28\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 25\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 29\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 38\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 30\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 02\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 01\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 39\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 09\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 36\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 23\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n1\n1\n0\n0\n0\n0\n1\n0\n0\n0\n\n\nBus 22\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n1\n1\n1\n0\n0\n0\n0\n0\n1\n0\n\n\nBus 35\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n1\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nBus 19\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n1\n1\n1\n0\n0\n0\n1\n\n\nBus 20\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n\n\nBus 33\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n1\n0\n1\n0\n0\n0\n0\n\n\nBus 24\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n1\n0\n0\n0\n0\n0\n1\n0\n0\n1\n\n\nBus 34\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n0\n1\n0\n0\n1\n0\n0\n\n\nBus 21\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n1\n0\n0\n0\n0\n0\n0\n1\n1\n\n\nBus 16\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n...\n0\n0\n0\n1\n0\n0\n1\n0\n1\n1\n\n\n\n\n39 rows × 39 columns\n\n\n\nTo get boolean values instead of zero and one, use ppi.get_connectivity_frame(net, boolean=True).",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#load-flow-jacobian",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#load-flow-jacobian",
    "title": "Network Matrices and Pandapower Interface",
    "section": "4 Load Flow Jacobian",
    "text": "4 Load Flow Jacobian\nThe load flow Jacobian matrix can be exported as well.\n\nnet._ppc[\"internal\"][\"J\"].todense()\n\nmatrix([[  46.27299714,    0.        ,    0.        , ...,    0.        ,\n            0.        ,    0.        ],\n        [   0.        ,   45.49863821,    0.        , ...,    0.        ,\n            0.        ,    0.        ],\n        [   0.        ,    0.        ,   67.13959559, ...,    0.        ,\n            0.        ,    0.        ],\n        ...,\n        [   0.        ,    0.        ,    0.        , ...,  205.55025042,\n            0.        , -175.3811615 ],\n        [   0.        ,    0.        ,    0.        , ...,    0.        ,\n          148.2388436 ,  -76.28193549],\n        [   0.        ,    0.        ,    0.        , ..., -174.4079501 ,\n          -75.90390706,  526.3356963 ]], shape=(67, 67))\n\n\nAn explanation of the Jacobian matrix entries is provided in the pandapower tutorial that was mentioned above already.",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#sec-format-comparison",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#sec-format-comparison",
    "title": "Network Matrices and Pandapower Interface",
    "section": "5 Format Comparison",
    "text": "5 Format Comparison\nThe dataformats of pandapower and PowerFactory are not fully compatible. An overview and functionality to rudimentary validate the exported data is presented in the following.\nRemember the exported dataset in pandapower format:\n\nnet\n\nThis pandapower network includes the following parameter tables:\n   - bus (39 elements)\n   - load (19 elements)\n   - gen (9 elements)\n   - switch (92 elements)\n   - ext_grid (1 element)\n   - line (34 elements)\n   - trafo (12 elements)\n and the following results tables:\n   - res_bus (39 elements)\n   - res_line (34 elements)\n   - res_trafo (12 elements)\n   - res_ext_grid (1 element)\n   - res_load (19 elements)\n   - res_gen (9 elements)\n   - res_switch (92 elements)\n\n\nThere are a few things to consider here (not everything is relevant for this example):\n\nbus considers all terminals, even those that are not energized\ngen are PV-controlled generators (active power and voltage)\nsgen are PQ-controlled generators\next_grid are generators/external grids which act as slack buses\nswitch considers only breakers/switches for branches, i.e. between buses or between buses and branch elements like lines and transformers (i.e. switches connecting generators are not considered for example)",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/network_matrices_and_pandapower_interface.html#validation",
    "href": "docs/tutorials/network_matrices_and_pandapower_interface.html#validation",
    "title": "Network Matrices and Pandapower Interface",
    "section": "6 Validation",
    "text": "6 Validation\n\n6.1 Using pandapower\npandapower has a function validate_pf_conversion (due to a bug in pandapower this function fails if load flow results are initially present) which compares load flow results and returns the differences.\n\nfrom pandapower.converter.powerfactory.validate import validate_pf_conversion\n\ntry:\n    act_prj.app.Hide()\n    net = ppi.pf_project_to_pandapower()\n    all_diffs = validate_pf_conversion(net)\nfinally:\n    act_prj.app.Show()\nall_diffs\n\nnumba cannot be imported and numba functions are disabled.\nProbably the execution is slow.\nPlease install numba to gain a massive speedup.\n(or if you prefer slow execution, set the flag numba=False to avoid this warning!)\n\n\n{'gen_p_diff_is':            diff  p_mw_pp  p_mw_pf\n 0  5.388387e-09    250.0    250.0\n 1  4.945377e-09    540.0    540.0\n 2  4.474373e-09   1000.0   1000.0\n 3  4.093181e-09    650.0    650.0\n 4  1.336514e-08    632.0    632.0\n 5  5.883180e-09    508.0    508.0\n 6  6.877826e-09    650.0    650.0\n 7  5.005631e-09    830.0    830.0\n 8  1.286480e-09    560.0    560.0,\n 'gen_q_diff_is':            diff   q_mvar_pp   q_mvar_pf\n 0 -1.990342e-06  146.158180  146.158178\n 1  3.744761e-06    0.439923    0.439926\n 2  3.910830e-07   88.281414   88.281415\n 3  1.046724e-06  205.144370  205.144371\n 4  2.652365e-06  109.905979  109.905981\n 5 -3.168794e-06  165.763652  165.763649\n 6  4.919206e-07  212.411826  212.411827\n 7  1.547455e-06   22.841623   22.841625\n 8  1.132399e-06  101.175009  101.175010,\n 'diff_vm':             diff  vm_pu_pp  vm_pu_pf\n 0   3.273640e-10  0.996020  0.996020\n 1   3.792664e-10  0.997001  0.997001\n 2   4.445253e-10  1.005311  1.005311\n 3   3.405909e-10  1.003863  1.003863\n 4   4.944176e-10  1.007672  1.007672\n 6   5.642395e-10  1.012694  1.012694\n 7  -5.276262e-10  1.000151  1.000151\n 8   6.057370e-10  1.017151  1.017151\n 9   4.730660e-13  0.983100  0.983100\n 10  5.251630e-10  1.014307  1.014307\n 11  3.384415e-10  1.011733  1.011733\n 12  6.859069e-11  1.015384  1.015384\n 13  2.709610e-12  1.027800  1.027800\n 14  1.137666e-10  1.033555  1.033555\n 15  2.069169e-10  1.037741  1.037741\n 16  1.420395e-10  1.030931  1.030931\n 17  1.683635e-10  1.030173  1.030173\n 18  1.896130e-10  1.052075  1.052075\n 19  8.532419e-11  1.050122  1.050122\n 20  1.678044e-10  1.057568  1.057568\n 21  9.517231e-11  1.049942  1.049942\n 22  2.565725e-12  1.026500  1.026500\n 23  2.665868e-12  1.047500  1.047500\n 24  1.697908e-11  1.048736  1.048736\n 25  5.274048e-11  1.047356  1.047356\n 26  1.442624e-12  1.030000  1.030000\n 27 -1.537583e-10  1.028226  1.028226\n 28  1.286082e-12  1.063500  1.063500\n 29 -3.145495e-10  1.044789  1.044789\n 30 -3.624545e-10  1.049795  1.049795\n 31  2.042588e-12  1.049300  1.049300\n 32  2.106224e-10  1.049861  1.049861\n 33  1.212996e-09  0.991177  0.991177\n 34  2.887468e-12  0.997200  0.997200\n 35 -9.434165e-11  1.037311  1.037311\n 36  3.113954e-12  1.012300  1.012300\n 37 -1.941558e-10  1.031760  1.031760\n 38 -4.588552e-12  1.031774  1.031774,\n 'diff_va':             diff  va_degree_pp  va_degree_pf\n 0   1.304982e-07    -10.615381    -10.615381\n 1   1.302315e-07    -10.123823    -10.123823\n 2   1.289775e-07     -8.611863     -8.611863\n 3   1.278345e-07     -9.606668     -9.606667\n 4   1.286948e-07     -7.949683     -7.949683\n 6   1.255758e-07     -6.284262     -6.284262\n 7   1.161739e-07     -6.243642     -6.243642\n 8   1.243239e-07     -5.427126     -5.427126\n 9  -5.807802e-08      2.568960      2.568960\n 10  1.254398e-07     -6.097718     -6.097718\n 11  1.264527e-07     -7.656411     -7.656411\n 12  1.247388e-07     -7.736092     -7.736092\n 13  4.192848e-07      2.421107      2.421107\n 14  1.232096e-07     -7.301286     -7.301285\n 15  1.205033e-07     -7.495423     -7.495423\n 16  1.239574e-07     -8.223858     -8.223858\n 17  1.253273e-07     -8.598549     -8.598549\n 18  1.186066e-07     -5.526725     -5.526725\n 19  1.160292e-07     -2.014886     -2.014886\n 20  1.186790e-07     -4.363392     -4.363391\n 21  1.149743e-07      0.744355      0.744355\n 22  2.239051e-07      7.807727      7.807727\n 23  1.987250e-07     -3.333993     -3.333993\n 24  1.261071e-07     -5.753762     -5.753762\n 25  1.272867e-07     -8.438685     -8.438685\n 26  1.284375e-07    -10.052962    -10.052961\n 27  1.298370e-07    -10.321987    -10.321987\n 28  1.555340e-07      8.322918      8.322918\n 29  1.286402e-07      0.470028      0.470028\n 30  1.290296e-07      0.668306      0.668306\n 31  2.881648e-07      5.630054      5.630054\n 32  1.243416e-07     -1.022768     -1.022768\n 33  8.781482e-08     -2.014676     -2.014676\n 34  4.317914e-08      4.194689      4.194689\n 35  1.243799e-07     -6.067907     -6.067907\n 36 -9.149473e-08      3.174992      3.174992\n 37  1.254547e-07     -3.780534     -3.780534\n 38  1.242053e-07     -6.187509     -6.187509,\n 'line_diff': 0     5.486263e-08\n 1     3.848433e-08\n 2    -5.150163e-08\n 3    -4.950159e-09\n 4     2.555265e-08\n 5     2.813952e-08\n 6     4.895907e-08\n 7     3.372672e-08\n 8    -2.410916e-07\n 9    -2.494211e-08\n 10   -1.323969e-08\n 11   -1.526541e-08\n 12    1.335349e-08\n 13   -7.175376e-08\n 14   -3.785573e-09\n 15   -3.613602e-08\n 16   -3.060009e-07\n 17    1.907268e-08\n 18   -1.125297e-07\n 19   -6.683092e-08\n 20    4.926250e-08\n 21   -3.236813e-08\n 22   -2.751835e-08\n 23    1.696872e-07\n 24    5.957066e-08\n 25   -9.428204e-08\n 26   -2.416880e-07\n 27   -2.474492e-08\n 28   -1.238898e-07\n 29   -3.017566e-08\n 30    1.673648e-07\n 31   -1.269707e-07\n 32    2.066898e-08\n 33    6.852896e-08\n dtype: float64,\n 'trafo_diff': 0     1.519598e-07\n 1     3.987861e-08\n 2    -3.555783e-08\n 3     4.051880e-08\n 4    -1.647721e-08\n 5    -1.595604e-07\n 6     6.224103e-08\n 7     2.759654e-08\n 8     1.979967e-08\n 9     3.799443e-09\n 10    1.862631e-09\n 11   -9.592349e-08\n dtype: float64,\n 'load_p_diff_is': 0     0.000000e+00\n 1    -5.684342e-14\n 2    -2.842171e-14\n 3     0.000000e+00\n 4     0.000000e+00\n 5     0.000000e+00\n 6    -2.842171e-14\n 7     5.684342e-14\n 8     0.000000e+00\n 9     0.000000e+00\n 10    2.842171e-14\n 11   -1.136868e-13\n 12    0.000000e+00\n 13   -8.881784e-16\n 14   -1.136868e-13\n 15    0.000000e+00\n 16   -5.684342e-14\n 17   -5.684342e-14\n 18    0.000000e+00\n dtype: float64,\n 'load_q_diff_is': 0     0.000000e+00\n 1    -3.552714e-15\n 2    -7.105427e-15\n 3     0.000000e+00\n 4     0.000000e+00\n 5     0.000000e+00\n 6     3.552714e-15\n 7    -7.105427e-15\n 8     0.000000e+00\n 9     2.842171e-14\n 10    1.421085e-14\n 11   -5.684342e-14\n 12    0.000000e+00\n 13   -1.421085e-14\n 14   -1.421085e-14\n 15   -1.421085e-14\n 16   -7.105427e-15\n 17    2.842171e-14\n 18    2.842171e-14\n dtype: float64,\n 'ext_grid_p_diff': 0    6.027556e-07\n dtype: float64,\n 'ext_grid_q_diff': 0    0.000001\n dtype: float64}\n\n\n\n\n6.2 Using powfacpy\npowfacpy offers a rudimentary validation of the exported dataset focusing only on data relevant for the admittance matrix. It is assumed that the currently active project in PowerFactory was used for the export. We can check the difference between both datasets by using get_difference_between_pf_and_pandapower_dataset.\nWe artificially set (and later undo) a deviation in the pandapower dataset here. A Dataframe with the divergent parameters is returned.\n\nfrom pandas import DataFrame\n\ntry:\n    pf_app.Hide()\n    net[\"bus\"].loc[0, \"vn_kv\"] = net[\"bus\"].loc[0, \"vn_kv\"] + 1\n\n    divergent_parameters = ppi.get_difference_between_pf_and_pandapower_dataset(net)\n    net[\"bus\"].loc[0, \"vn_kv\"] = net[\"bus\"].loc[0, \"vn_kv\"] - 1\n\nfinally:\n    pf_app.Show()\n\ndivergent_parameters\n\n\n\n\n\n\n\n\nname\npf_class\npp_parameter\npf_value\npp_value\n\n\n\n\n0\nBus 08\nElmTerm\nvn_kv\n345.0\n346.0\n\n\n\n\n\n\n\nget_difference_between_pf_and_pandapower_dataset assumes default settings for the units in the PowerFactory project (see *Settings).\nAs mentioned, only a subset of classes and parameters is validated. The following mapping is used:\n\nppi.get_pandapower_2_pf_class_mapping()\n\n{'bus': ['ElmTerm'],\n 'line': ['ElmLne'],\n 'trafo': ['ElmTr2', 'ElmTr3'],\n 'impedance': ['ElmZpu', 'ElmSind']}\n\n\nThe parameter mapping is defined in get_pandapower_2_pf_parameter_mapping. It is best understood by looking at the source code and we use python’s inspect module to print the method. The mapping is either between the pandapower parameter strings or between a pandapower* parameter string and and a callable with the PowerFactory object as argument and returning the parameter value (used for example to get parameters from the type object).\n\nimport inspect\n\nprint(f\"{inspect.getsource(ppi.get_pandapower_2_pf_parameter_mapping)}\")\n\n    def get_pandapower_2_pf_parameter_mapping(\n        self,\n    ) -&gt; dict[str, dict[str, str | Callable]]:\n        \"\"\"Get parameter mapping between pandapower and PowerFactory.\n\n        Only a small subset of all the parameters is currently implemented.\n\n        Returns:\n            dict[str, dict[str, str | Callable]]: For each pf class, a mapping between the pandapower and the pf parameter is provided. The pf parameter can be a string or a callable (input is the pf object; used for example to access a parameter of the type).\n        \"\"\"\n        return {\n            \"ElmTerm\": {\n                \"vn_kv\": \"uknom\",\n            },\n            \"ElmLne\": {\n                \"length_km\": \"dline\",\n                \"parallel\": \"nlnum\",\n                \"r_ohm_per_km\": lambda x: x.typ_id.rline,\n                \"x_ohm_per_km\": lambda x: x.typ_id.xline,\n                \"c_nf_per_km\": lambda x: x.typ_id.cline\n                * 1000  # from micro to nano\n                * x.typ_id.frnom  # nominal frequency is adapted to 50 Hz by pandapower\n                / 50.0,\n                \"g_us_per_km\": lambda x: x.typ_id.gline,\n            },\n            \"ElmTr2\": {\n                \"sn_mva\": lambda x: x.typ_id.strn,\n                \"parallel\": \"ntnum\",\n                \"vn_hv_kv\": lambda x: x.typ_id.utrn_h,\n                \"vn_lv_kv\": lambda x: x.typ_id.utrn_l,\n                \"vk_percent\": lambda x: x.typ_id.uktr,\n                \"vkr_percent\": lambda x: x.typ_id.uktrr,\n            },\n            \"ElmTr3\": {\n                \"parallel\": \"nt3nm\",\n                \"sn_hv_mva\": lambda x: x.typ_id.strn3_h,\n                \"sn_mv_mva\": lambda x: x.typ_id.strn3_m,\n                \"sn_lv_mva\": lambda x: x.typ_id.strn3_l,\n                \"vn_hv_kv\": lambda x: x.typ_id.utrn3_h,\n                \"vn_mv_kv\": lambda x: x.typ_id.utrn3_m,\n                \"vn_lv_kv\": lambda x: x.typ_id.utrn3_l,\n                \"vk_hv_percent\": lambda x: x.typ_id.uktr3_h,\n                \"vk_mv_percent\": lambda x: x.typ_id.uktr3_m,\n                \"vk_lv_percent\": lambda x: x.typ_id.uktr3_l,\n                \"vkr_hv_percent\": lambda x: x.typ_id.uktrr3_h,\n                \"vkr_mv_percent\": lambda x: x.typ_id.uktrr3_m,\n                \"vkr_lv_percent\": lambda x: x.typ_id.uktrr3_l,\n            },\n            \"ElmZpu\": {\n                \"sn_mva\": \"Sn\",\n                \"rft_pu\": \"r_pu\",\n                \"xft_pu\": \"x_pu\",\n            },\n            \"ElmSind\": {\n                \"sn_mva\": \"Sn\",\n                \"rft_pu\": lambda x: (x.rrea * x.Sn) / (x.ucn**2),\n                \"xft_pu\": lambda x: (x.xrea * x.Sn) / (x.ucn**2),\n            },\n        }",
    "crumbs": [
      "Tutorials",
      "Network Matrices and Pandapower Interface"
    ]
  },
  {
    "objectID": "docs/tutorials/database.html",
    "href": "docs/tutorials/database.html",
    "title": "Database Interface",
    "section": "",
    "text": "# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    \"C:\\\\Program Files\\\\DIgSILENT\\\\PowerFactory 2025 SP3\\\\Python\\\\3.13\"\n)  # you may use a different directory\n\nimport powerfactory\n\nfrom powfacpy import ActiveProject\nfrom powfacpy.applications.database import Database\n\napp = powerfactory.GetApplication()\napp.Show()\nact_prj = ActiveProject(app)\npfdb = Database(app)\nact_prj.app.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\nact_prj.activate_study_case(r\"Study Cases\\test_active_project_interface\\Study Case 1\")\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\test_active_project_interface\\Study Case 1.IntCase&lt;/l1&gt;&gt;\nclass_params = {\n    \"ElmTerm\": [\"outserv\"],\n    \"ElmLod\": [\"plini\", \"qlini\", \"typ_id.aP\"],\n    \"ElmTr*\": [\"typ_id\"],\n}\n\nterminals = act_prj.get_calc_relevant_obj(\"*.ElmTerm\")\nloads = act_prj.get_calc_relevant_obj(\"*.ElmLod\", includeOutOfService=0)\ntransformers = act_prj.get_calc_relevant_obj(\"*.Elmtr*\", includeOutOfService=0)\ntry:\n    app.Hide()\n    obj_attr = pfdb.get_object_attributes(terminals + loads + transformers, class_params)\nfinally:\n    app.Show()    \nobj_attr\n\n{&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\Terminal HV 2.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\Terminal MV.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\Terminal HV 1.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\Terminal HV 2_2.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\Terminal HV 1_2.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\Terminal MV_2.ElmTerm&lt;/l1&gt;&gt;: {'outserv': 0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\General Load HV.ElmLod&lt;/l1&gt;&gt;: {'plini': 2.0,\n  'qlini': 1.0,\n  'typ_id.aP': 0.0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\General Load MV.ElmLod&lt;/l1&gt;&gt;: {'plini': 0.0,\n  'qlini': 0.0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\General Load MV_2.ElmLod&lt;/l1&gt;&gt;: {'plini': 0.0,\n  'qlini': 0.0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\General Load HV_2.ElmLod&lt;/l1&gt;&gt;: {'plini': 2.0,\n  'qlini': 0.0},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_active_project_interface\\Grid.ElmNet\\2-Winding Transformer.ElmTr2&lt;/l1&gt;&gt;: {'typ_id': &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Library.IntPrjfolder\\Equipment Type Library.IntPrjfolder\\90 MVA 132/33 kV.TypTr2&lt;/l1&gt;&gt;},\n &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_case_studies\\Grid 1.ElmNet\\2-Winding Transformer_2.ElmTr2&lt;/l1&gt;&gt;: {'typ_id': &lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Library.IntPrjfolder\\Equipment Type Library.IntPrjfolder\\90 MVA 132/33 kV.TypTr2&lt;/l1&gt;&gt;}}\ntry:\n    app.Hide()\n    class_params = {\n        \"ElmTerm\": [\"outserv\"],\n        \"ElmLod\": [\"plini\", \"qlini\", \"typ_id.aP\"],\n        \"ElmTr*\": [\"typ_id\"],\n    }\n    obj_attr = pfdb.get_object_attributes(\n        terminals + loads + transformers, \n        class_params, \n        keys_are_pf_obj=False, \n        values_are_pf_obj=False, \n        )\nfinally:\n    app.Show()    \nobj_attr\n\n{'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\Terminal HV 2.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\Terminal MV.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\Terminal HV 1.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\Terminal HV 2_2.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\Terminal HV 1_2.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\Terminal MV_2.ElmTerm': {'outserv': 0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\General Load HV.ElmLod': {'plini': 2.0,\n  'qlini': 1.0,\n  'typ_id.aP': 0.0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\General Load MV.ElmLod': {'plini': 0.0,\n  'qlini': 0.0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\General Load MV_2.ElmLod': {'plini': 0.0,\n  'qlini': 0.0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\General Load HV_2.ElmLod': {'plini': 2.0,\n  'qlini': 0.0},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_active_project_interface\\\\Grid.ElmNet\\\\2-Winding Transformer.ElmTr2': {'typ_id': 'Library.IntPrjfolder\\\\Equipment Type Library.IntPrjfolder\\\\90 MVA 132/33 kV.TypTr2'},\n 'Network Model.IntPrjfolder\\\\Network Data.IntPrjfolder\\\\test_case_studies\\\\Grid 1.ElmNet\\\\2-Winding Transformer_2.ElmTr2': {'typ_id': 'Library.IntPrjfolder\\\\Equipment Type Library.IntPrjfolder\\\\90 MVA 132/33 kV.TypTr2'}}\nimport pickle\n\nwith open('database_dict.pickle', 'wb') as handle:\n    pickle.dump(obj_attr, handle)\n\nwith open('database_dict.pickle', 'rb') as handle:\n    obj_attr_loaded = pickle.load(handle)\ntry:\n    app.Hide()\n    pfdb.set_pf_obj_attribute_values(obj_attr_loaded)\nfinally:\n    app.Show()"
  },
  {
    "objectID": "docs/tutorials/database.html#replace-duplicate-loc_name",
    "href": "docs/tutorials/database.html#replace-duplicate-loc_name",
    "title": "Database Interface",
    "section": "2.1 Replace Duplicate ‘loc_name’",
    "text": "2.1 Replace Duplicate ‘loc_name’\n\ntry:\n    app.Hide()\n    obj_occurences = pfdb.make_loc_name_unique(pf_classes=[\"Elm*\"])\nfinally:\n    app.Show() \nobj_occurences\n\n{'Voltage source ctrl.ElmComp': 1,\n 'Angle.ElmDsl': 1,\n 'Frequency.ElmDsl': 1,\n 'Magnitude.ElmDsl': 1,\n 'Line 1.ElmLne': 1,\n 'Line 1_2.ElmLne': 1,\n 'General Load HV.ElmLod': 1,\n 'General Load MV.ElmLod': 1,\n 'General Load MV_2.ElmLod': 1,\n 'General Load HV_2.ElmLod': 1,\n 'Summary Grid.ElmNet': 1,\n 'Grid.ElmNet': 1,\n 'Grid 1.ElmNet': 1,\n 'Results1.ElmRes': 1,\n 'Results2.ElmRes': 1,\n 'Terminal HV 2.ElmTerm': 1,\n 'Terminal MV.ElmTerm': 1,\n 'Terminal HV 1.ElmTerm': 1,\n 'Terminal HV 2_2.ElmTerm': 1,\n 'Terminal HV 1_2.ElmTerm': 1,\n 'Terminal MV_2.ElmTerm': 1,\n '2-Winding Transformer.ElmTr2': 1,\n '2-Winding Transformer_2.ElmTr2': 1,\n 'AC Voltage Source.ElmVac': 1,\n 'AC Voltage Source_2.ElmVac': 1}"
  },
  {
    "objectID": "docs/index.html",
    "href": "docs/index.html",
    "title": "powfacpy",
    "section": "",
    "text": "1 Introduction\npowfacpy is a wrapper around the Python API of PowerFactory© (software for power system simulation by DIgSILENT). You can automate almost anything in PowerFactory© with the native API, but the syntax can be verbose. Therefore, powfacpy provides features and interface classes to make your life easier.\nFor example, setting attributes of an object in the PowerFactory© database requires several lines of code with the native API. With the API of powfacpy, this is only one line:\nset_attr(r\"Network Model\\Network Data\\Grid\\Terminal MV\",{\"uknom\":33,\"outserv\":0})\nHere we have set two attributes (uknom, outserv) of the object specified under the path Network Mod….\nPlotting also requires many lines with the native API (you need to add the variable to the monitored variables, create a plot page, add the curve,..). Using powfacpy the syntax is succinct and similar to matplotlib. Just activate a plot and then plot variables of an object:\nset_active_plot(\"Active power\",\"§ PV plant\")\nplot(r\"Network Model\\Network Data\\Grid\\PV\", \"m:Psum:bus1\")\npowfacpy will save you time and make your code more readable. Get started with the Tutorials.\n\n\n2 Why use powfacpy?\nThere are a number of reasons why you should consider using powfacpy:\n\nIncrease productivity\nWrite more readable code\nAvoid running into similar problems, errors and obscurities as other users of the python interface of PowerFactory did before you\nHaving a standard way of doing things in your organization (e.g. a standard format for simulation result export)\nSteep learning curve for PowerFactory beginners (helpful tutorials)\n\n\n\n3 Installation\nUsing pip:\npip install powfacpy\n\n\n4 Contact\nsimon.eberlein@iee.fraunhofer.de or open an issue.\n\n\n5 Contribute\nContributions (new features, bug reports, feature requests, etc.) are very welcome on Github. If you want to contribute to the code base, please have a look at How to contribute.\n\n\n6 About\npowfacpy is an open source package which is mainly developed at Fraunhofer IEE and not associated with DIgSILENT.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/docs/release_notes.html",
    "href": "docs/docs/release_notes.html",
    "title": "Release Notes",
    "section": "",
    "text": "New class interfaces for DSL models (block definitions, slots, …)\nAdd COMTRADE interface for plotting\nNew (preliminary) interface for static calculations (power flow,..)\nNew convenient method to set attributes and later reset their original value\nPossibility to get certain converter types (grid-forming, grid-following) inside groupings (zones, boundaries,..)",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/docs/release_notes.html#v0.4.0",
    "href": "docs/docs/release_notes.html#v0.4.0",
    "title": "Release Notes",
    "section": "",
    "text": "New class interfaces for DSL models (block definitions, slots, …)\nAdd COMTRADE interface for plotting\nNew (preliminary) interface for static calculations (power flow,..)\nNew convenient method to set attributes and later reset their original value\nPossibility to get certain converter types (grid-forming, grid-following) inside groupings (zones, boundaries,..)",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/docs/release_notes.html#v0.3.7",
    "href": "docs/docs/release_notes.html#v0.3.7",
    "title": "Release Notes",
    "section": "v0.3.7",
    "text": "v0.3.7\n\nNew features for topology (boundaries, areas,…) and CGMES model exchange (see tutorials)\nbugfixes\n\nget_vacant_cubicle\nrearrange_Y_bus_frame\nget_average_internal_susceptance",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/docs/release_notes.html#v0.3.0",
    "href": "docs/docs/release_notes.html#v0.3.0",
    "title": "Release Notes",
    "section": "v0.3.0",
    "text": "v0.3.0\n\nStructural changes:\n\nIn this version, the structure of powfacpy has changed fundamentally\nPlease have a look at Structure of powfacpy to understand the new structure and why the restructuring was necessary\nInstead of PFBaseInterface the class ActiveProject from base/active_project should be used\nInterfaces for plotting, case study, etc. are now found under applications/.\nAll former interface classes can still be used, but their files are located in a folder called deprecated and you will get deprecation warnings\n\nThere should be few breaking changes. Some of the known are:\n\nThe labels of the result export to pandas have changed (see the tutorial)\nThe name of the method export_results_of_study_cases of the class PFStudyCases has changed to export_results_of_study_cases_to_csv\n\nblack formatter was introduced as the standard formatter for python code\nThe format of the website was changed from sphinx to quarto\nFunctionality:\n\nInterface for network topology was added\nInterfaces to several single PowerFactory classes was added (see src/powfacpy/pf_classes/)",
    "crumbs": [
      "Docs",
      "Release Notes"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html",
    "href": "docs/docs/how_to_contribute.html",
    "title": "How to Contribute",
    "section": "",
    "text": "Contributions in the form of issues (bug reports, feature requests, etc.) and to the codebase are very welcome.\nIf you want to contribute to the codebase there are a few things to consider which are described in the following. Note that any valuable contribution is appreciated even if they do not adhere to all of the following guidelines. And if you have questions just open an issue.",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#where-should-i-add-a-new-feature",
    "href": "docs/docs/how_to_contribute.html#where-should-i-add-a-new-feature",
    "title": "How to Contribute",
    "section": "1 Where should I add a new feature?",
    "text": "1 Where should I add a new feature?\nIt is recommended to read through the description of the structure of powfacpy to select a suitable location of the new feature (usually either in the applications or the pf_classes folder).",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#should-i-add-tests",
    "href": "docs/docs/how_to_contribute.html#should-i-add-tests",
    "title": "How to Contribute",
    "section": "2 Should I add tests?",
    "text": "2 Should I add tests?\nIt is good practice to add unit tests using the pytest package. Unit tests are located in the tests folder, which has a similar folder structure as the source code. The unit tests require PowerFactory test projects which you can find under tests/tests_input/. They need to be added in the PowerFactory database to the folder specified in settings.json (attribute path to powfacpy folder in PowerFactory database). If you adapt those .pfd files for your tests, don’t forget to commit the new version.",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/how_to_contribute.html#how-can-i-showcase-the-functionality-of-the-feature",
    "href": "docs/docs/how_to_contribute.html#how-can-i-showcase-the-functionality-of-the-feature",
    "title": "How to Contribute",
    "section": "3 How can I showcase the functionality of the feature?",
    "text": "3 How can I showcase the functionality of the feature?\nTo expose features to a wider range of users, adding a tutorial is more effective than just adding source code. Tutorials are located in the docs/tutorials folder. Like the whole website, they are written in quarto (markdown like syntax with extended features). If you prefer working with jupyter notebooks, you can easily convert jupyter notebooks to quarto (.qmd) with the command quarto convert my_tutorial.ipynb. Finally, to make the .qmd file appear on the website, it must be added to the *_quart.yml* file in the root directory, e.g.:\nsidebar:\n- title: \"Tutorials\"\n    style: \"docked\"\n    contents:\n    - docs/tutorials/overview.qmd\n    - docs/tutorials/getting_started.qmd\n    - docs/tutorials/simulation_and_plotting.qmd\n    - docs/tutorials/study_cases.qmd\n    - docs/tutorials/my_tutorial.qmd",
    "crumbs": [
      "Docs",
      "How to Contribute"
    ]
  },
  {
    "objectID": "docs/docs/overview.html",
    "href": "docs/docs/overview.html",
    "title": "Overview",
    "section": "",
    "text": "Please use the sidebar to navigate through the documentation.\n\n\n\n Back to top",
    "crumbs": [
      "Docs",
      "Overview"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html",
    "href": "docs/docs/structure_of_powfacpy.html",
    "title": "Structure of powfacpy",
    "section": "",
    "text": "The structure of the source code of powfacpy (see folder src/powfacpy) is the explained in the following. At first, the basics relevant for users of powfacpy are introduced. Then some more advanced topics are elaborated for power users and contributors to the package in Section 2.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#sec-active-project",
    "href": "docs/docs/structure_of_powfacpy.html#sec-active-project",
    "title": "Structure of powfacpy",
    "section": "1.1 Active Project",
    "text": "1.1 Active Project\n\nbase/active_project.py\n\nThe class ActiveProject in base/active_project.py is the main interface to the database of PowerFactory as illustrated in the Getting Started Tutorial.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#sec-pf-classes",
    "href": "docs/docs/structure_of_powfacpy.html#sec-pf-classes",
    "title": "Structure of powfacpy",
    "section": "1.2 PowerFactory Classes",
    "text": "1.2 PowerFactory Classes\n\npf_classes/\n\nThis is a collection of interface classes that refer directly to individual classes in the PowerFactory database. The classes “inherit” (more details in Section 2) from the classes in the PowerFactory database and add further functionality. For example, the SynchronousMachine class (in pf_classes/elm/sym) has all data and functionality (as described in the python scripting reference of PowerFactory) of PowerFactory’s ElmSym class, but adds further functionality (e.g. a secure way of getting the rated apparent power, which considers the number of parallel machines).\nThe classes in the PowerFactory database can be grouped based on the first three letters and the remaining part of their names (e.g. Elm + Sym, where Elm is common to all network element classes and Sym is short for synchronous machine). This is reflected by the subfolders (elm, sta, set, etc.) which contain the interface classes for each subgroup. The files in the subfolders are named accordingly, but the full names are used for the classes in the files (e.g. sym.py in the elm folder contains the class SynchronousMachine) to distinguish the class names from the protocol classes (see below). To create an instance, an instance of the native PowerFactory class must be provided, as in the following example:\nfrom powfacpy.pf_classes.elm.sym import SynchronousMachine\nfrom powfacpy.base.active_project import ActiveProject\n\nact_prj = ActiveProject()\nsm_pf_native = act_prj.get_calc_relevant_object(\"SM 01.ElmSym\")\nsm = SynchronousMachine(sm_pf_native)\nsm.Disconnect() # Method from native PF object\nx = sm.get_averaged_internal_reactance() # Method from powfacpy.pf_classes.elm.sym\nIn addition, pf_classes/protocols.py contains protocol classes for (almost) all classes from the PowerFactory database (automatically created, see protocol_generator.py). They are used for type hints for example, as explained in the Getting Started Tutorial.\n\n\n\n\n\n\nWarningProtocols\n\n\n\nNote that there is a protocols.py file in the root directory for compatibility with versions prior to 0.3.0. It will be deprecated and pf_classes/protocols.py should be used.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#applications",
    "href": "docs/docs/structure_of_powfacpy.html#applications",
    "title": "Structure of powfacpy",
    "section": "1.3 Applications",
    "text": "1.3 Applications\n\napplications/\n\nIn comparison to the PowerFactory classes from Section 1.2, this folder contains applications that are more complex than an interface to a single PowerFactory class. The applications are more complicated and often require multiple native PowerFactory classes. Examples are interfaces for plotting, dynamic simulation, results export, network topology analysis, study cases, etc.\nApplication classes usually have an attribute that is an instance of ActiveProject (see Section 1.1) to interact with the active project. Prior to version 0.3.0, Application classes inherited from ActiveProject instead, but this cluttered the Application classes with many methods (ActiveProject is large). Hence, it was decided that composition is the better option.\n\n\n\n\n\n\nTipComparison of PowerFactory classes and Applications\n\n\n\nAs a rule of thumb, any functionality that involves only one native PowerFactory class should be accommodated in an interface class in the pf_classes/ folder. Applications can make use of this functionality. This prevents too much functionality from being packed into the application classes.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#result-variables",
    "href": "docs/docs/structure_of_powfacpy.html#result-variables",
    "title": "Structure of powfacpy",
    "section": "1.4 Result Variables",
    "text": "1.4 Result Variables\n\nresult_variables.py\n\nThe file result_variables.py contains (automatically created) enumeration classes for results variables (e.g. of dynamic simulations) and it is created by executing result_variables_parser.py. The usage is explained in the Simulation and Plotting Tutorial.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#deprecated",
    "href": "docs/docs/structure_of_powfacpy.html#deprecated",
    "title": "Structure of powfacpy",
    "section": "1.5 Deprecated",
    "text": "1.5 Deprecated\n\ndeprecated/ (not shown in Figure 1)\n\nThis folder contains files used in versions prior to 0.3.0 for compatibility.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#base",
    "href": "docs/docs/structure_of_powfacpy.html#base",
    "title": "Structure of powfacpy",
    "section": "2.1 base",
    "text": "2.1 base\nThis folder contains base classes that are used in for Application and PowerFacory classes and the ActiveProject class.\n\n2.1.1 base/folder.py\nThis file contains the Folder class which provides functionality to interact with the PowerFactory database, such as getting objects and setting attributes of objects inside a folder in the PowerFactory database. To interact with PowerFactory, it holds the PowerFactory app as a class attribute.\n\n\n2.1.2 base/active_project.py\nThe file contains the ActiveProject class that inherits from the Folder class and adds functionality specific to the active project in PowerFactory. The class ActiveProjectCached can be more performant than ActiveProject as it caches the properties, but it should be used only in one project (the caching fails after a different project was activated).\n\n\n2.1.3 base/base.py\nThis file contains base classes for PowerFactory interface classes (see Section 1.2). Instances of such classes usually hold one data attribute (the native PowerFactory object). In some use cases, numerous instances will have to be created (e.g. for all terminals in a network). Therefore, it is essential that these classes access and allocate their data efficiently. This is implemented in the BaseObjectStatic class using slots.\nThe class BaseChildStatic inherits from BaseObjectStatic and adds functionality to inherit behavior from native PowerFactory objects (see Section 1.2) by overloading the methods __getattribute__ and __setattr__.\n\n\n2.1.4 base/functional.py\nThis is a functional interface to be used as a (limited) alternative to ActiveProject and Folder. Performance can be improved as there are more restrictions on the input arguments (for example, only PowerFactory objects are accepted and not their path string).",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#pf_classes",
    "href": "docs/docs/structure_of_powfacpy.html#pf_classes",
    "title": "Structure of powfacpy",
    "section": "2.2 pf_classes",
    "text": "2.2 pf_classes\nThe classes in the pf_classes folder usually overload the method __new__ with the following boilerplate code (exemplified for SynchronousMachine):\n    def __new__(cls, *args, **kwargs) -&gt; ElmSym | SynchronousMachine:\n        \"\"\"Implemented only to add type hints for the created instance.\n\n        Returns:\n            ElmSym | SynchronousMachine: New instance\n        \"\"\"\n        instance = super().__new__(cls)\n        return instance\nThe sole reason is to make type hints work.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#engineering_helpers.py",
    "href": "docs/docs/structure_of_powfacpy.html#engineering_helpers.py",
    "title": "Structure of powfacpy",
    "section": "2.3 engineering_helpers.py",
    "text": "2.3 engineering_helpers.py\nThese are generic helper functions in the electrical and power engineering domain.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/docs/structure_of_powfacpy.html#exceptions.py",
    "href": "docs/docs/structure_of_powfacpy.html#exceptions.py",
    "title": "Structure of powfacpy",
    "section": "2.4 exceptions.py",
    "text": "2.4 exceptions.py\nThis is a collection of custom exceptions of powfacpy. Custom exceptions can provide more information on what goes wrong and are easier to catch for any python code that uses powfacpy.",
    "crumbs": [
      "Docs",
      "Structure of *powfacpy*"
    ]
  },
  {
    "objectID": "docs/tutorials/cgmes_model_exchange.html",
    "href": "docs/tutorials/cgmes_model_exchange.html",
    "title": "CGMES handling with model exchange interface",
    "section": "",
    "text": "1 About CGMES\nCGMES stands for Common Grid Model Exchange Standard. It is a standard developed to facilitate the exchange of grid models and data among different stakeholders in the power system industry, such as utilities, system operators, and software vendors.\nCGMES is structured using several profiles, each contained in a separate file. An exemplary selection of profiles is given in Table 1.\n\n\n\nTable 1: Subselection of CGMES profiles\n\n\n\n\n\n\n\n\n\nAbbreviation\nDescription\n\n\n\n\nSSH\nSteady State Hypothesis (steady state Load Flow Data with changeable parameters)\n\n\nEQ\nEquipment Model\n\n\nTP\nTopology profile: contains all topology objects, i.e. how equipment is electrically connected.\n\n\nSV\nState Variables\n\n\nDL\nDiagram Layout\n\n\n\n\n\n\nFor more information on CGMES, visit the following links: Video, ENTSO-E website, and Document.\n\n\n2 Model exchange interface\nThe model exchange application of powfacpy contains functionalities to import and export CGMES data, as well as to update an existing CGMES grid with new data, for example from an SSH file.\nThis tutorials demonstrates how to\n\nImport CGMES\nExport CGMES\nUpdate CGMES using SSH and DL profiles\n\nFirst, activate the PowerFactory project as outlined in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2025 SP3\\Python\\3.13\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\napp.Show()\n\nGet powfacpy objects (CGMES interface class and ActiveProject)\n\npfcgmes = CGMES(app)\npfp = pfcgmes.act_prj\n\nActivate the study case:\n\nstudy_case = pfp.get_unique_obj(r'Study Cases\\test_model_exchange_interfaces\\Study Case')\nstudy_case.Activate()\n\n0\n\n\nThe following grid exists in that project.\n\n\n\n\n\n\nFigure 1: Grid for export\n\n\n\n\n\n3 Export to CGMES\nFirst, let’s export this grid to CGMES. The function cgmes_export() exports the active grid to OUTPUT_PATH.\n\nOUTPUT_PATH = r\"..\\..\\tests\\tests_output\\cgmes_export\"\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"all\", as_zip=True)\n\nInfo: The CGMES export can trigger error messages in the PowerFactory output window, but these do not usually affect the correctness of the exported data.\n\n\nic| output_path: '..\\\\..\\\\tests\\\\tests_output\\\\cgmes_export'\n\n\nHere we can see the exported file.\n\n\n\n\n\n\nFigure 2: Exported ZIP file with all CGMES profiles\n\n\n\nIt is a .zip file, because we configured as_zip=True.\nWe can also export the separate files directly into the folder by setting as_zip=False. Additionally we can choose which profiles to export:\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"ssh dl sv\", as_zip=False)\n\nInfo: The CGMES export can trigger error messages in the PowerFactory output window, but these do not usually affect the correctness of the exported data.\n\n\nic| output_path: '..\\\\..\\\\tests\\\\tests_output\\\\cgmes_export'\n\n\nNow we exported the .xml files (not zipped) and only got SSH, DL and SV:\n\n\n\n\n\n\nFigure 3: Selected profiles, unzipped\n\n\n\n\n\n4 Import from CGMES\nNow we could import our grid into another simulation software. Here, we just import again to PowerFactory.\nWe’ll demonstrate this by switching to a different study case and importing the grid again.\n\nstudy_case.Deactivate()\n\nnew_study_case = pfp.create_in_folder(\n    \"New Study Case.IntCase\",\n    study_case.GetParent(),\n    overwrite=True,\n)\nnew_study_case.Activate()\n\n0\n\n\nThen import the previously exported CGMES files using cgmes_import()\n\nnew_grid = pfcgmes.cgmes_import(\n    OUTPUT_PATH + \"\\\\\" \n    + pfcgmes.exported_zip_name # default name that pfcgmes uses for exported zip file\n    + \".zip\"\n)\n\n\nnew_grid.Activate()\n\n0\n\n\nThe imported grid will have the same name as the original.\nImport location is the root of the network data folder. The imported grid has a different folder structure than the original and a library folder with model types is imported together with the grid.\n\n\n\n\n\n\nFigure 4: Structure of imported grid\n\n\n\nBut the resulting grid model still looks the same as the original:\n\n\n\n\n\n\nFigure 5: Imported grid\n\n\n\n\n\n5 Update model with external data\nUsing CGMES, we can update a model using external data (e.g. SSH and DL).\nIn this case, we will think of study_case as some external reference model. We will change its data and update new_study_case accordingly using CGMES.\n\nstudy_case.Activate()\n\n0\n\n\nAll our loads have reactive power setpoints.\n\n\n\n\n\n\nFigure 6: Original reactive power setpoints of loads\n\n\n\nLet’s change them in the reference model. We will set them to 0, just as an example.\n\npfp.app.Hide()\n\nreference_grid = pfp.get_unique_obj(r'Network Model\\Network Data\\test_model_exchange_interfaces\\Grid')\nfor load in pfcgmes.act_prj.get_obj(\"*.ElmLod\", include_subfolders=True, parent_folder=reference_grid):\n    load.qlini = 0\n\npfp.app.Show()\n\nNow the reactive power of all loads in the reference model are 0:\n\n\n\n\n\n\nFigure 7: new reactive power in reference model\n\n\n\nWhile in the new model it is still like it was before:\n\n\n\n\n\n\nFigure 8: Reactive power in imported model\n\n\n\nTo update our new model with the change in reference model, we first export the reference model’s changes to CGMES using the SSH and DL profiles.\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"ssh dl\", as_zip=True)\n\nInfo: The CGMES export can trigger error messages in the PowerFactory output window, but these do not usually affect the correctness of the exported data.\n\n\nic| output_path: '..\\\\..\\\\tests\\\\tests_output\\\\cgmes_export'\n\n\nThen we take this to our new model.\n\nnew_study_case.Activate()\n\n0\n\n\nWe need to supply the CIM archive that we used to import the new model. It is used as a base archive and needed for the update.\n\nbase_archive = pfcgmes.act_prj.get_unique_obj(\n    pfcgmes.import_archive_name, parent_folder=pfcgmes.archive_folder\n)\n\nAnd by running update_profiles() we can update our new model.\n\npfcgmes.update_profiles(\n    update_file_path=OUTPUT_PATH + \"\\\\\" + pfcgmes.exported_zip_name + \".zip\", \n     base_archive=base_archive\n)\n\nNow, the changes made in the reference model are also present in our new model.\n\n\n\n\n\n\nFigure 9: Changes to reference model were transferred to new model\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "CGMES handling with model exchange interface"
    ]
  },
  {
    "objectID": "docs/tutorials/getting_started.html",
    "href": "docs/tutorials/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code. Furthermore, the error messages powfacpy provides are a great help when debugging larger scripts or in larger projects that use the python API of PowerFactory.\nFor a complete list of classes and methods, please have a look at the API Chapter of the documentation or at the source code.\nSimilar to using the Python API of PowerFactory directly, we first need to import the powerfactory module from PowerFactory’s installation directory (in case you want to access PowerFactory externally using IPython/Jupyter) and get the application.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    \"C:\\\\Program Files\\\\DIgSILENT\\\\PowerFactory 2025 SP3\\\\Python\\\\3.13\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\n\nThen import powfacpy and create an instance of class ActiveProject (with argument app). This interface class is mainly used to interact with the active project in the PowerFactory database as we will see below.\n\nfrom powfacpy import ActiveProject\n\nact_prj = ActiveProject(app)\n\nNote that pfp has an attribute app that can be used similar to the app variable we loaded from the powerfactory module.\nThe PowerFactory project used in this tutorial can be found in the powfacpy repository under *tests_input_tests.pfd*.\nHere are two ways to 1. show the PowerFactory application and 2. activate a project:\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\nact_prj.app.Show()\nact_prj.app.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\nSo where does pfp differ from the Python interface that app provides? Let’s see.\n\n1 Accessing Objects\nLet’s access an object from the PowerFactory database. When using app, we would use the methods app.GetProjectFolder, app.GetChildren or app.GetContents. Instead, we use act_prj.get_obj with the path of the object (relative to the folder of the active project) as an argument:\n\nmv_terminal = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\"\n)[0]\n\nThe [0] at the end is necessary because the method always returns a list (with one element in this case).\nNote that you can easily copy and paste the path from the data manager while selecting the object in the data tree:\n\n\n\nobject path\n\n\nact_prj.get_obj also differs in other ways from app.GetContents and app.GetCalcRelevantObjects. You can set a condition for the objects that you want to access, which is best described by an example:\n\nhv_terminals = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\",\n    condition=lambda x: x.uknom &gt; 50,\n)\n\nFirst of all, we use a wildcard (*.ElmTerm) to access all terminals in the Grid folder. The condition argument is a function that defines a certain condition the objects have to fulfill and returns a boolean value. In this case, the input argument x is an ElmTerm and x.uknom &gt; 50 gets its attribute uknom (nominal voltage) and checks whether it is larger than 50 (kV). Using this .uknom notation is equivalent to using getattr(x, \"uknom\"), which is a python method that returns an attribute of any object (also PowerFactory objects). You can also define more complex functions, such as lambda x: x.uknom &gt; 50 and x.uknom &lt; 200 to access terminals between 50 and 200 kV.\nIt is also possible to include subfolders in the search for objects:\n\nterminals = act_prj.get_obj(\n    r\"Network Model\\Network Data\\*.ElmTerm\", include_subfolders=True\n)\n\nThis will search in Network Model\\Network Data and all its subfolders (by default include_subfolders is False, be carefull as including all subfolders in the search can affect the performance).\nWhat’s also very helpful is that act_prj.get_obj throws an error if the path is incorrect and shows exactly where it fails. So\nterminals = act_prj.get_obj(r\"Network Model\\wrong_folder_name\\*.ElmTerm\")\nwill throw an error:\nPFPathError: ‘wrong_folder_name’ does not exist in ’_baseModel’\nBy default, an exception is also raised if no objects are found in the specified folder. For example:\nterminals = act_prj.get_obj(r\"Network Model\\Network Data\\wrong_object_name*\", include_subfolders=True)\nreturns\nPFPathError: ’wrong_object_name*’ does not exist in ’_baseModelData’\nCatching such errors early in your development can save some headache and time for debugging.\nThis can be turned off by setting the optional argument error_if_non_existent=False, then an empty list will be returned.\nIf you want to access objects in a folder many times and don’t want to use the whole path relative to the active project every time, you can also specifiy a parent folder where the search path starts (this can also be more performant):\n\ngrid_folder = act_prj.get_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\"\n)[0]\n\nmv_terminal = act_prj.get_obj(\"Terminal MV\", parent_folder=grid_folder)[0]\nhv_terminal = act_prj.get_obj(\"Terminal HV 1\", parent_folder=grid_folder)[0]\n\nYou can also use brackets to call get_obj (the ActiveProject class defines a __getitem__ method that calls get_obj without optional arguments):\n\nterminals = act_prj[\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\*.ElmTerm\"\n]\n\nThe get_obj command can become verbose with many keyword arguments. This can be inconvenient, for example when you have to call the method many times with the same arguments. powfacpy provides the get_object_partial method which returns a Callable. This way you can define new variations of get_obj:\n\nget_obj_subf = act_prj.get_obj_partial(include_subfolders=True)\n# This can now be used with further arguments of 'get_obj' as follows (and will always assume 'include_subfolders=True'):\nterminals = get_obj_subf(\"*.ElmTerm\", parent_folder=grid_folder)\n\nUnder the hood the partial function from the built-in functools module of Python is used (it is actually pretty simple to do the above with any Python method/function). Note that for the commonly required inclusion of subfolders in the search there is actually a separate method get_obj_including_subfolders available (another alternative for network objects in get_calc_relevant_obj as described below).\nAn alternative to act_prj.get_obj is act_prj.get_unique_obj. Use this function if you want to access a single unique object (i.e. an object that you expect to only exist once) from the database and want to avoid the [0] (which is easily forgotten).\n\nterminal_1 = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\n\nget_unique_obj will throw an error if the specified path is not attributable to a single unique object (i.e. also when two or more objects are found).\nFinally, yet another alternative for getting network objects is get_calc_relevant_obj: powfacpy wraps the GetCalcRelevenatObjects method and adds optional arguments, similar to get_obj:\n\nterminals = act_prj.get_calc_relevant_obj(\n    \"ElmTerm\", \n    error_if_non_existent=False, \n    condition=lambda x: x.uknom &gt; 100, \n    includeOutOfService=0\n)\n\n\n\n2 Accessing Project Folders and Data\nThe ActiveProject class defines a number of properties to directly access relevant project folders (under the hood, the GetProjectFolder and GetDataFolder methods are used). Here are some examples (you may just type act_prj.folder and your IDE will autocomplete all the properties):\n\nact_prj.study_cases_folder  # This is a getter property returning StudyCases.IntPrjfolder\nact_prj.network_model_folder\nact_prj.zones_folder\nact_prj.variations_folder\nact_prj.operation_scenarios_folder\n# ...\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Operation Scenarios.IntPrjfolder&lt;/l1&gt;&gt;\n\n\nTo get all active grids/networks (ElmNet) use:\n\nactive_networks = act_prj.get_active_networks()\n# act_prj.app.GetCalcRelevantObjects(\".ElmNet\") also returns the summary grid in the study case which is usually not desired.\n\n\n\n3 Getting Objects from the Active Study Case\nThe native GetFromStudyCase method returns the first object found that satisfies the criteria or creates a new object in the active study case. This is a common source of errors when more than one object satisfies the criteria and this goes unnoticed (this often happens for example when users work on the same project with different language settings). You can use the powfacpy method instead which prints a warning or raises an error if the the object found is not unique:\n\nresults_obj = act_prj.get_from_study_case(\"ElmRes\", if_not_unique=\"warning\")\n\nD:\\User\\seberlein\\FraunhIEE-UniKassel-PowSysStability\\powfacpy\\docs\\tutorials\\..\\..\\src\\powfacpy\\base\\active_project.py:235: UserWarning: The returned *.ElmRes object is not unique in the  study case: 'Study Cases\\test_active_project_interface\\Study Case 1'. Make sure that the correct *.ElmRes object is used: &lt;l3&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\test_active_project_interface\\Study Case 1.IntCase\\Results1.ElmRes&lt;/l3&gt;.\n  warn(\n\n\n\n\n4 Type Hints\nType hints are used in Python to improve the readability and code completion, but do not actually affect the excuted code (except when you do static type checking). They are often seen in function/method definitions and are preceded by a colon, e.g.:\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nThis means that the function expects two input arguments of type integer and returns an integer. powfacpy defines protocol classes for (almost) all PowerFactory classes (more than 200) from the scripting reference (with very few exceptions) and a few additional classes (such as ‘IntSite’ which is not mentioned in the scripting reference).\nIn the following example a type hint is used (‘:ElmTerm’). Your IDE will then autocomplete all attributes (methods and data) of the variable ‘terminal’:\n\nfrom powfacpy.pf_classes.protocols import ElmTerm\n\nhv_terminal: ElmTerm = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal HV 1\"\n)\nhv_terminal.uknom\n\n110.0\n\n\nAny modern IDE should autocomplete your code while writing:\n\n\n\ntype_hints\n\n\nNote that this also works with lists:\n\nterminals: list[ElmTerm] = act_prj.get_calc_relevant_obj(\"ElmTerm\")\n\n\n\n5 Setting and Getting Object Attributes\nHow about setting data in the database? You can set attributes of an object as follows:\n\nact_prj.set_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    {\"uknom\": 33, \"outserv\": 0},\n)\n\nSo with only one command we set the attributes “uknom” and “outserv” of the terminal. This saves time and is also very readable code. Note that the method set_attr accepts the path (string) but also a PowerFactory object. For example, we could also use the object mv_terminal that we loaded above:\n\nact_prj.set_attr(mv_terminal, {\"uknom\": 33, \"outserv\": 0})\n\nThis applies to many other methods in powfacpy. Loading the object only once and then using the object can be more efficient than using the path string many times.\nSometimes you want to quickly apply a few changes to attributes of objects for some testing and later retain the original values. If you use set_attr_resettable, every time you call this method, the original values of the attributes are stored in a stack. You can then use reset_stored_attr to reset the attributes to their original values.\n\nact_prj.set_attr_resettable(mv_terminal, {\"uknom\": 35, \"outserv\": 1})\nact_prj.set_attr_resettable(hv_terminal, {\"outserv\": 1})\nprint(f\"New values:{mv_terminal.uknom, mv_terminal.outserv, hv_terminal.outserv}\")\nact_prj.reset_stored_attr()\nprint(f\"Original values: {mv_terminal.uknom, mv_terminal.outserv, hv_terminal.outserv}\")\n\nNew values:(35.0, 1, 1)\nOriginal values: (33.0, 0, 0)\n\n\nIf you want to get an attribute of an object, write:\n\nnominal_voltage = act_prj.get_attr(\n    r\"Network Model\\Network Data\\test_active_project_interface\\Grid\\Terminal MV\",\n    \"uknom\",\n)\n\n\n# Equivalent:\nnominal_voltage = act_prj.get_attr(mv_terminal, \"uknom\")\nnominal_voltage = act_prj.get_attr(\n    \"Terminal MV\",\n    \"uknom\",\n    parent_folder=r\"Network Model\\Network Data\\test_active_project_interface\\Grid\",\n)\n\n\n\n6 Creating Objects and Directories\nIf you want to create a new object, use:\n\nfrom powfacpy.pf_class_protocols import BlkDef, IntPrjfolder\n\nnew_obj: BlkDef = act_prj.create_by_path(r\"Library\\Dynamic Models\\dummy.BlkDef\")\n\nThis will create an object of class “BlkDef” with the name “dummy” in the folder “LibraryModels”. You can also use\n\nnew_obj: BlkDef = act_prj.create_in_folder(\n    \"dummy.BlkDef\", r\"Library\\Dynamic Models\", overwrite=True\n)\n\n# Or equivalent:\nmodels_folder: IntPrjfolder = act_prj.get_unique_obj(r\"Library\\Dynamic Models\")\nnew_obj: BlkDef = act_prj.create_in_folder(\n    \"dummy.BlkDef\", models_folder, overwrite=True\n)\n\nwhich will overwrite the former object (this avoids that PowerFactory creates dummy(1), dummy(2), … every time the code is run). overwrite=True is the default setting.\nTo create a directory, i.e. a nested folder structure, use\n\nact_prj.create_directory(\n    r\"New Study Case\\Cases Normal Opration\", parent_folder=\"Study Cases\"\n)\n\n&lt;powerfactory.DataObject &lt;l1&gt;\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Study Cases.IntPrjfolder\\New Study Case\\Cases Normal Opration&lt;/l1&gt;&gt;\n\n\n\n\n7 Copying Objects\nThe method copy_obj can be seen as a method that uses get_obj as a first step to access objects and then copies them to a target folder under the hood. Therefore, copy_obj shares many (optional) input arguments with get_obj to first get the objects to be copied. Additionally, a target folder is required. For example, to copy all objects from a source folder to a target folder, write\n\nsource_folder = r\"Library\\Dynamic Models\\TestDummyFolder\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nnew_copied_objects = act_prj.copy_obj(\"*\", target_folder, parent_folder=source_folder)\n\nNote that parent folder is an optional argument (used for the source), so you could also specify the full object path as the first argument instead of using * (similar to get_obj). To select certain objects from the source folder, you can use optional arguments like condition or include_subfolders, also similar to the get_obj method. The method also accepts a list of PowerFactory objects:\n\nlist_of_objects_to_copy = act_prj.get_obj(\"*\", parent_folder=source_folder)\ntarget_folder_obj = act_prj.get_unique_obj(r\"Library\\Dynamic Models\\TestCopyMultiple\")\nnew_copied_objects = act_prj.copy_obj(\n    list_of_objects_to_copy, target_folder_obj, overwrite=True\n)\n\nNote that the target folder object (instead of a path string) is used (second argument).\nIf you want to copy a single object, use copy_single_obj. You have the option to give it a new name (loc_name attribute):\n\nnew_copy = act_prj.copy_single_obj(\n    r\"Library\\Dynamic Models\\Linear_interpolation\",\n    r\"Library\\Dynamic Models\\TestCopy\",\n    new_name=\"new_dummy_name\",\n)\n\nFirst input here is the path of the object to be copied, but you can also use a PowerFactory object.\n\n\n8 Moving Objects\nThe syntax to move objects is similar to copying:\n\n# Multiple objects\nsource_folder = r\"Library\\Dynamic Models\\TestCopy\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\nact_prj.move_obj(\"*\", target_folder, parent_folder=source_folder)\n\n# Single object\nsource_folder = r\"Library\\Dynamic Models\\TestCopyMultiple\"\ntarget_folder = r\"Library\\Dynamic Models\\TestCopy\"\nact_prj.move_single_obj(\"dummy\", target_folder, parent_folder=source_folder)\n\n0\n\n\n\n\n9 Deleting Objects\nDeleting objects works in a similar fashion, because under the hood it uses get_obj and deletes the returned objects in the second step.\n\nact_prj.delete_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    include_subfolders=True,\n    error_if_non_existent=False,\n)\n\nAnd of course you could also use PowerFactory objects as an input:\n\nobjects_in_folder = act_prj.get_obj(\n    \"to_be_deleted*\",\n    parent_folder=r\"Library\\Dynamic Models\\TestDelete\",\n    error_if_non_existent=False,\n)\n\nact_prj.delete_obj(objects_in_folder, error_if_non_existent=False)\n\nYou can also delete all objects in a folder:\n\nact_prj.clear_folder(\"Library\\Dynamic Models\\TestDelete\")\n\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\D'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\D'\nC:\\Users\\seberlein\\AppData\\Local\\Temp\\ipykernel_23752\\4033900814.py:1: SyntaxWarning: invalid escape sequence '\\D'\n  act_prj.clear_folder(\"Library\\Dynamic Models\\TestDelete\")\n\n\n\n\n10 Further Useful Methods\nFurther helpful methods are briefly described in the following. get_upstream_obj returns an upstream object that meets a condition (i.e. the method goes upwards in the folder hierarchy until a parent object is found that meets the condition).\nHere this is used to find the grid that contains a given object:\n\nobj = act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\\test_database_interface\\Grid\\Voltage source ctrl\\Frequency\"\n)\ngrid = act_prj.get_upstream_obj(obj, lambda x: x.loc_name == \"Grid\")\nprint(act_prj.get_path_of_object(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\n\n\nget_path_of_object returns the path of an object relative to the active project and without any class names. The user can can directly copy the returned string to the data manager to quickly find the object in the PowerFactory app.\n\n\n\nobject path\n\n\nThere are more methods to get the path of an object:\n\nprint(act_prj.get_path_of_object(grid))  # path inside project\nprint(act_prj.get_path_of_obj_with_class_names(grid))\nprint(act_prj.get_full_path_of_object(grid))  # full path in database\nprint(act_prj.get_full_path_of_object_with_class_names(grid))\nprint(act_prj.get_path_of_object_in_active_project(grid))\nprint(act_prj.get_path_of_object_in_active_project_with_class_names(grid))\n\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\\seberlein\\powfacpy\\powfacpy_tests_copy_where_tests_run\\Network Model\\Network Data\\test_database_interface\\Grid\n\\seberlein.IntUser\\powfacpy\\powfacpy_tests_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\nNetwork Model\\Network Data\\test_database_interface\\Grid\nNetwork Model.IntPrjfolder\\Network Data.IntPrjfolder\\test_database_interface\\Grid.ElmNet\n\n\n\n\n11 The Folder Class\nMost of the functionality described above is not limited to the folder of the active project, but can be used with any folder in the database. The class ‘Folder’ can be used with any folder. Path input arguments are then relative to that folder (and not to the active project as above, unless of course a ‘parent_folder’ is specified):\n\nfrom powfacpy.base.folder import Folder\n\nnetwork_data_folder = Folder(r\"Network Model\\Network Data\", app)\n\n\ngrid = network_data_folder.get_unique_obj(\n    \"test_active_project_interface\\Grid\"\n)  # relative to 'Network Data' folder\n\n\nprint(network_data_folder.get_path_of_object(grid))\n\ntest_active_project_interface\\Grid\n\n\n&lt;&gt;:7: SyntaxWarning: invalid escape sequence '\\G'\n&lt;&gt;:7: SyntaxWarning: invalid escape sequence '\\G'\nC:\\Users\\seberlein\\AppData\\Local\\Temp\\ipykernel_23752\\1597339306.py:7: SyntaxWarning: invalid escape sequence '\\G'\n  \"test_active_project_interface\\Grid\"\n\n\nNote that ‘Folder’ instances are iterable. For example, you can use a for-loop to iterate through the (direct) children of the folder:\n\nfor object in network_data_folder:\n    print(network_data_folder.get_path_of_object(object))\n\nAreas\nBackbones\nVirtual Power Plants\nBoundaries\nCable Layouts\nCircuits\nDistribution correlations\nFeeders\nMeteo Stations\nOperators\nOwners\nPaths\nRoutes\nZones\ntest_plot_interface\nnetwork_for_elmfiles\ntest_case_studies\ntest_dyn_sim_interface\ntest_active_project_interface\ntest_network_interface\ntest_results_interface\ntest_database_interface\ntest_model_exchange_interfaces\ntemp_grid\nGrid\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Getting Started"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html",
    "href": "docs/tutorials/overview.html",
    "title": "Overview",
    "section": "",
    "text": "The following tutorials illustrate the functionality of powfacpy. You can use the PowerFactory project under *tests_input_tests.pfd* to run the commands in the tutorials locally. You can follow the link to Github on the right to download the tutorials in .qmd format (quarto). If you prefer jupyter notebook format, you can convert them with quarto convert &lt;tutorial_name.qmd&gt; (assuming quarto is installed).",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#getting-started",
    "href": "docs/tutorials/overview.html#getting-started",
    "title": "Overview",
    "section": "1 Getting started",
    "text": "1 Getting started\nStart here with the getting started tutorial. This tutorial gives an overview of the interaction with the PowerFactory database using powfacpy. The methods introduced in this tutorial serve as a basis to do more complex things and to write more readable code using less lines of code.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#dynamic-simulation-and-plotting",
    "href": "docs/tutorials/overview.html#dynamic-simulation-and-plotting",
    "title": "Overview",
    "section": "2 Dynamic Simulation and Plotting",
    "text": "2 Dynamic Simulation and Plotting\nThe tutorial shows how to conveniently simulate and plot with a syntax similar to matplotlib. It is also depicted how to export data to pandas and csv formats and use external plotting libraries such as matplotlib.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#study-cases",
    "href": "docs/tutorials/overview.html#study-cases",
    "title": "Overview",
    "section": "3 Study Cases",
    "text": "3 Study Cases\nThe study cases tutorial illustrates how to automatically create study cases for parameter studies.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#network-matrices-and-pandapower-interface",
    "href": "docs/tutorials/overview.html#network-matrices-and-pandapower-interface",
    "title": "Overview",
    "section": "4 Network Matrices and Pandapower Interface",
    "text": "4 Network Matrices and Pandapower Interface\nThis tutorial demonstrates how to export network matrices such as admittance or Jacobian matrix using the Pandapower interface as an intermediate step.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#topology-and-groupings",
    "href": "docs/tutorials/overview.html#topology-and-groupings",
    "title": "Overview",
    "section": "5 Topology and Groupings",
    "text": "5 Topology and Groupings\nThe tutorial on topology and groupings focuses on the grouping of network elements into boundaries, zones and areas.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/overview.html#cgmes-model-exchange",
    "href": "docs/tutorials/overview.html#cgmes-model-exchange",
    "title": "Overview",
    "section": "6 CGMES Model Exchange",
    "text": "6 CGMES Model Exchange\nIn the cgmes model exchange tutorial you can learn how to get started with the application.model_exchange tool to export, import or update grid models using CGMES.",
    "crumbs": [
      "Tutorials",
      "Overview"
    ]
  },
  {
    "objectID": "docs/tutorials/study_cases.html",
    "href": "docs/tutorials/study_cases.html",
    "title": "Study Cases",
    "section": "",
    "text": "Parameter studies are organized in study cases, operation scenarios and variations in PowerFactory. This tutorials shows how to create parameter studies with ease and fully automated using the study cases interface of powfacpy.\nFirst, we activate the PowerFactory project as in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\n0\n\n\n\n1 Simple Parameter Study\nWe use the class StudyCases. This class inherits from PFActiveProject, so all methods from that class are available. We want to create study case with various values for the active and reactive power of a load.\nFirst we set the attribute parameter_values and define a dictionary with parameter names and a list of values. Each element in the lists is used in one study case.\n\nfrom powfacpy.applications.study_cases import StudyCases\n\npfsc = StudyCases(app)\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc.parameter_values = {\n    \"p HV load\": [1,   2, 1, 2],\n    \"q HV load\": [-1, -1, 1, 1], \n}\n# fmt: on\n\nHere we have defined four study cases and in the first case p HV load equals 1 and q HV load equals -1. The parameter names must not contain *?=“,~|()! as these characters cannot be used for names of objects in PF.\nNext we connect the variables to the PF database by defining a dictionary with paths in the attribute parameter_paths using the same parameter names as keys. The paths include the attribute name (e.g. plini which is the active power of the load).\n\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\plini\",  # This is one string split over several lines\n    \"q HV load\": r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\n\nFinally we define the active grids. For now, we assume that for all cases exactly one grid is active (we look at more complicated cases later).\n\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\n\nNow let’s create the study cases (and corresponding operation scenarios) in a new folder named ‘Autocreated’:\n\npfsc.parent_folder_study_cases = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.study_cases_folder\n)\npfsc.parent_folder_scenarios = pfsc.act_prj.create_in_folder(\n    \"Autocreated.IntFolder\", folder=pfsc.act_prj.operation_scenarios_folder\n)\n# Alternatively, just use\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\npfsc.create_cases()\n\nThis creates the following study cases in the ‘Autocreated’ folder:\n\nThe names of the study cases are created according to the parameter names and their values (“_” is used instead of “=” which is not allowed in PF object names). Furthermore, the corresponding operation scenarios are created:\n\nFor more complicated case studies with further parameters, it is advisable to structure the cases in folders. We define the attribute hierarchy using a list (in this case with onl yone item) of parameter names that corresponds to folder directories.\n\npfsc.hierarchy = [\"q HV load\"]\npfsc.create_cases()\n\nNow q HV load is used for the folder names and not in the study case name.\n\nThe structure of the operation scenarios is similar.\n\n\n2 Advanced Parameter Study\nLet’s take a look at a more complex parameter study.\n\n# Turn auto formatting off for readability of parameter_values\n# fmt: off\npfsc = StudyCases(app)\npfsc.parameter_values = {\n    \"p HV load\":    [1,   2, 2,  1,  1,  2,  1,  2,],\n    \"q HV load\":    [-1, -1, 1,  1,  -1, -1, 1,  1,],\n    \"control\":      [\"A\",\"A\",\"A\",\"A\",\"B\",\"B\",\"B\",\"B\"],\n}\n# fmt: on\npfsc.parameter_paths = {\n    \"p HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\plini\",\n    \"q HV load\": r\"Network Model\\Network Data\\test_case_studies\\Grid 2\\General Load HV\\qlini\",\n}\npfsc.active_grids = r\"Network Model\\Network Data\\test_case_studies\\Grid 2\"\npfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n\nAn additional parameter control is defined. Note that there is no parameter path defined for this parameter. The parameter can be seen as a placeholder for the study cases structure and to do more complicated things than simply setting an attribute of a PF object later (we’ll see below).\nBy default, study cases and operation scenarios are created. If variations should be created in addition, use:\n\npfsc.add_variation_to_each_case = True\n\nThis can be necessary because some parameters, like attributes of DSL objects, are stored in variants and not in operation scenarios. Let’s again create the study cases.\n\npfsc.hierarchy = [\"control\", \"q HV load\"]\npfsc.create_cases()\n\nThis creates the following structure in the network variations (as well as in the scenarios and study cases):\n\nLet’s set further parameters, add plots (using plot interface) and simulate (using dyn. simulation interface) for each study case. The study case objects are stored in the study_cases attribute. We can iterate through the cases and set parameters depending on the previously defined control parameter.\n\nfrom powfacpy.applications.plots import Plots\nfrom powfacpy.applications.dynamic_simulation import DynamicSimulation\n\npfpi = Plots(app)\npfds = DynamicSimulation(app)\ndsl_controller_obj = pfsc.act_prj.get_unique_obj(\n    r\"Network Model\\Network Data\"\n    r\"\\test_case_studies\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\n\n\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    study_case_obj.Activate()\n    # Set controller parameters\n    if pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"A\":\n\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 0, \"VFlag\": 1})\n    elif pfsc.get_value_of_parameter_for_case(\"control\", case_num) == \"B\":\n        pfsc.act_prj.set_attr(dsl_controller_obj, {\"PfFlag\": 1, \"VFlag\": 0})\n    # Prepare plots\n    pfpi.clear_plot_pages()\n    pfpi.set_active_plot(\"Reactive current\", \"WPP\")\n    pfpi.plot(dsl_controller_obj, \"s:Iqcmd\")\n    # Simulate\n    pfds.initialize_and_run_sim()\n\nLet’s walk through this piece of code. The plotting and simulation interfaces are instantiated and a DSL object is assigned to be used later.\nIt is iterated through the study cases objects (and case numbers) and each study case is activated. Then the controller parameters are set. The value of the control parameter is obtained using the method get_value_of_parameter_for_case and the controller parameters are set depending on the controller type (A or B). This provides the flexibility to adjust the study cases depending on previously defined parameters in any way (e.g. set parameters, activate grids, …). And all settings are stored in the previously defined operation scenarios/variations.\nFinally, a plot is created for every case and the dynamic simulation is executed.\n\n\n3 Compare Study Cases\nIt is often required to compare the results of cases. In the following, we use the previously defined cases to compare the simulation results for cases where the parameter p HV load equals 1 (note that you may have to “Rebuild”  the plot in the upper left for PF to show it correctly):\n\n# Create a study case where results from other cases are compared in a plot\nstudy_case_comparison = pfsc.act_prj.create_by_path(\n    r\"Study Cases\\Autocreated\\Comparison.IntCase\"\n)\nstudy_case_comparison.Activate()\npfpi.clear_plot_pages()\npfpi.set_active_plot(\n    \"Reactive current controller setpoint for p HV load = 1\", \"Comparison \"\n)\ndsl_controller_obj = (\n    r\"Network Model\\Network Data\\test_case_studies\"\n    r\"\\Grid 2\\WECC WT Control System Type 4A\\REEC_A Electrical Control Model\"\n)\nfor case_num, study_case_obj in enumerate(pfsc.study_cases):\n    if pfsc.get_value_of_parameter_for_case(\"p HV load\", case_num) == 1:\n        # Get results object from respective study case\n        results_obj = pfsc.act_prj.get_unique_obj(\n            \"*.ElmRes\", parent_folder=study_case_obj\n        )\n        # Create label for plot\n        case_label = pfsc.get_case_params_value_string(\n            case_num, omitted_parameters=\"p HV load\", delimiter=\" | \", equals_sign=\"=\"\n        )\n        label = \"Iq setpoint (\" + case_label + \")\"\n        # Plot\n        pfpi.plot(dsl_controller_obj, \"s:Iqcmd\", results_obj=results_obj, label=label)\n\nThis creates a plot with legend:\n\nLet’s walk through the code. After creating a study case where the results are compared in a plot, it is again iterated through all cases. For cases where p HV load has a certain value, the result object is fetched. Next we want to create a label for the curve in the plot. We use the method get_case_params_value_string with certain options for the delimiter and the equals symbol (here we have more options than for PF object names, i.e. = and | are allowed). Moreover, the parameter p HV load is omitted because it is the same for all compared cases (i.e. 1, see condition). Further information on the variable is added to the label and the curve is finally added to the plot.\nAn alternative to iterating through all study cases is to get certain cases using the method get_study_cases:\n\nstudy_cases_p_HV_load_equals_1 = pfsc.get_study_cases({\"p HV load\": lambda x: x == 1})\nfor study_case_obj in study_cases_p_HV_load_equals_1:\n    pass\n    # do something with the specific cases\n\nget_study_cases takes a dictionary as input, where lambda functions with conditions for parameters are defined. Note that the methods get_value_of_parameter_for_case and get_case_params_value_string also work with study case objects as inputs instead of case numbers.\nA very convenient yet powerful alternative to ‘get_study_cases’ especially for complicated conditionals is ‘get_study_cases_from_string’. This method simply accepts a string which can contain complicated conditionals:\n\nstudy_cases_from_conditionals = pfsc.get_study_cases_from_string(\n    \"p HV load &gt;= 2 and (control == 'A' or q HV load != 1)\"\n)\n\nThat makes it very easy to plot and compare certain cases.\n\n\n4 Permutation\nIt is also possible to create study cases for the permutation of the parameters (i.e. all combinations). This is achieved with the method apply_permutation. Define the parameter values first (and also the hierarchy if applicable) and then call the method. Make sure that the PF application is hidden to improve the performance (if not hidden, this can take minutes and otherwise only seconds - the ‘try-finally’ block ensures that the app is always shown in the end even if an exception is thrown):\n\ntry:\n    pfsc = StudyCases(app)\n    pfsc.act_prj.app.Hide()\n    pfsc.parameter_values = {\n        \"p HV load\": [1, 2, 3],\n        \"q HV load\": [-1, 1],\n        \"control 1\": [\"A\", \"B\"],\n        \"control 2\": [\"R\", \"S\"],\n    }\n    pfsc.hierarchy = [\n        \"p HV load\",\n        \"control 1\",\n    ]\n    pfsc.apply_permutation()\n    pfsc.set_parent_folders_for_cases_scenarios_variations(\"Autocreated\")\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    pfsc.act_prj.app.Show()\n\napply_permutation irreversibly replaces the values in parameter_values with the permutation.\nIt may be desirable to use the permutation but omit certain combinations. These omitted combinations can be defined in a list of dictionaries and used as a keyword argument as follows (note that we clear the parent folders from the formerly created objects first):\n\ntry:\n    app.Hide()\n    omitted_combinations = [\n        {\"q HV load\": [1], \"control 2\": [\"R\"]},\n        {\"p HV load\": [2, 3], \"control 1\": \"all\"},\n    ]\n    pfsc.apply_permutation(omitted_combinations=omitted_combinations)\n    pfsc.clear_parent_folders()\n    pfsc.create_cases()\nfinally:\n    app.Show()\n\nThe first dictionary causes any combinations where “q HV load” is 1 and “control 2” is “R” to be omitted (these cases will not be created when create_cases is called). In the second dictionary, the keyword “all” is used. This means that all combinations with this parameter are omitted.\n\n\n5 Further Functionality\nThe attributes of StudyCases instances allow to set further options.\nThe study case names can be numbered consecutively setting consecutively_number_case_names.\nSometimes it is convenient to use only parameter values without the parameter names for the folder/study case names (imagine the value of a parameter is expressive enough and you don’t want to use “Controller_GridCode2012Controller” but only “GridCode2012Controller” instead). This can be achieved by adding parameters to the list of anonymous_parameters (e.g. pfsc.anonymous_parameters=[\"Controller\",\"FurtherParName\"]).\n\n\n\n\n Back to top",
    "crumbs": [
      "Tutorials",
      "Study Cases"
    ]
  },
  {
    "objectID": "tutorials/cgmes_model_exchange.html",
    "href": "tutorials/cgmes_model_exchange.html",
    "title": "CGMES handling with model exchange interface",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\n\n1 About CGMES\nCGMES stands for Common Grid Model Exchange Standard. It is a standard developed to facilitate the exchange of grid models and data among different stakeholders in the power system industry, such as utilities, system operators, and software vendors.\nCGMES is structured using several profiles, each contained in a separate file. An exemplary seleciton of profiles is given in Table 1.\n\n\n\nTable 1: Subselection of CGMES profiles\n\n\n\n\n\n\n\n\n\nAbbreviation\nDescription\n\n\n\n\nSSH\nSteady State Hypothesis (steady state Load Flow Data with changeable parameters)\n\n\nEQ\nEquipment Model\n\n\nTP\nTopology profile: contains all topology objects, i.e. how equipment is electrically connected.\n\n\nSV\nState Variables\n\n\nDL\nDiagram Layout\n\n\n\n\n\n\nFor more information on CGMES, visit the following links: Video, ENTSO-E website, and Document.\n\n\n2 Model exchange interface\nThe model exchange application of powfacpy contains functionalities to import and export CGMES data, as well as to update an existing CGMES grid with new data, for example from an SSH file.\nThis tutorials demonstrates how to\n\nImport CGMES\nExport CGMES\nUpdate CGMES using SSH and DL\n\nFirst, activate the PowerFactory project as outlined in the getting started tutorial.\n\n# If you use IPython/Jupyter:\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2024 SP4\\Python\\3.10\"\n)  # you may use a different directory\n\n# Get the PF app\nimport powerfactory\nimport powfacpy\n\napp = powerfactory.GetApplication()\napp.ActivateProject(\n    r\"powfacpy\\powfacpy_tests_copy_where_tests_run\"\n)  # You may change the project path.\n\napp.Show()\n\nGet powfacpy objects\n\npfcgmes = CGMES(app)\npfp = pfcgmes.act_prj\n\nActivate study case\n\nstudy_case = pfp.get_unique_obj(r'Study Cases\\test_model_exchange_interfaces\\Study Case')\nstudy_case.Activate()\n\n1\n\n\nThe following grid exists in that project.\n\n\n\n\n\n\nFigure 1: Grid for export\n\n\n\n\n\n3 Export to CGMES\nFirst, let’s export this grid to CGMES. The function cgmes_export() exports the active grid to OUTPUT_PATH.\n\nOUTPUT_PATH = r'..\\tests\\tests_output\\cgmes_export'\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"all\", as_zip=True)\n\nHere we can see the exported file.\n\n\n\n\n\n\nFigure 2: Exported ZIP file with all CGMES profiles\n\n\n\nIt is a .zip file, because we configured as_zip=True.\nWe can also get the separate files directly into the folder by setting as_zip=False. Additionally we can choose which profiles to export:\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"ssh dl sv\", as_zip=False)\n\nNow we exported the .xml files (not zipped) and only got SSH, DL and SV:\n\n\n\n\n\n\nFigure 3: Selected profiles, unzipped\n\n\n\n\n\n4 Import from CGMES\nNow we could import our grid into another simulation software.\nHere, we’ll demonstrate this by switching to a different study case and importing the grid again.\n\nstudy_case.Deactivate()\n\nnew_study_case = pfp.create_in_folder(\n    \"New Study Case.IntCase\",\n    study_case.GetParent(),\n    overwrite=True,\n)\nnew_study_case.Activate()\n\n0\n\n\nThen import the previously exported CGMES files using cgmes_import()\n\nnew_grid = pfcgmes.cgmes_import(\n    OUTPUT_PATH + \"\\\\\" \n    + pfcgmes.exported_zip_name # default name that pfcgmes uses for exported zip file\n    + \".zip\"\n)\n\n\nnew_grid.Activate()\n\n0\n\n\nThe imorted grid will have the same name as the original.\nImport location is the root of the network data folder. It has a different folder structure than the original and a library folder with model types is imported with the grid.\n\n\n\n\n\n\nFigure 4: Structure of imported grid\n\n\n\nBut the resulting grid model still looks the same as the original:\n\n\n\n\n\n\nFigure 5: Imported grid\n\n\n\n\n\n5 Update model with external data\nUsing CGMES, we can update a model using external data (e.g. SSH and DL).\nIn this case, we will think of study_case as some external reference model. We will change its data and update new_study_case using CGMES.\n\nstudy_case.Activate()\n\n0\n\n\nAll our loads have reactive power setpoints.\n\n\n\n\n\n\nFigure 6: Original reactive power setpoints of loads\n\n\n\nLet’s change them in the reference model. We will set them to 0, just as an example.\n\npfp.app.Hide()\n\nreference_grid = pfp.get_unique_obj(r'Network Model\\Network Data\\test_model_exchange_interfaces\\Grid')\nfor load in pfcgmes.act_prj.get_obj(\"*.ElmLod\", include_subfolders=True, parent_folder=reference_grid):\n    load.qlini = 0\n\npfp.app.Show()\n\nNow the reactive power of all loads in the reference model are 0:\n\n\n\n\n\n\nFigure 7: new reactive power in reference model\n\n\n\nWhile in the new model it is still like it was before:\n\n\n\n\n\n\nFigure 8: Reactive power in imported model\n\n\n\nTo update our new model with the change in reference model, we first export the reference model’s changes to CGMES using the SSH and DL profiles.\n\npfcgmes.cgmes_export(OUTPUT_PATH, selected_profiles=\"ssh dl\", as_zip=True)\n\nThen we take this to our new model.\n\nnew_study_case.Activate()\n\n0\n\n\nWe need to supply the CIM archive that we used to import the new model. It is used as a base archive and needed for the update.\n\nbase_archive = pfcgmes.act_prj.get_unique_obj(\n    pfcgmes.import_archive_name, parent_folder=pfcgmes.archive_folder\n)\n\nAnd by running update_profiles() we can update our new model.\n\npfcgmes.update_profiles(\n    update_file_path=OUTPUT_PATH + \"\\\\\" + pfcgmes.exported_zip_name + \".zip\", \n     base_archive=base_archive\n)\n\nNow, the changes made in the reference model are also present in our new model.\n\n\n\n\n\n\nFigure 9: Changes to reference model were transferred to new model\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html",
    "href": "tutorials/simulation_and_plotting.html",
    "title": "Simulation and Plotting",
    "section": "",
    "text": "The tutorials have been moved to the website. The version here is no longer maintained.\nThe following tutorial introduces dynamic simulations (RMS/EMT), plotting and exporting of results (to pandas or csv) using powfacpy.\nLet’s again set up PowerFactory and create an instance of powfacpy’s Plots class. This class inherits from ActiveProject (so those methods are available). We use the ‘39-Bus New England’ example from PowerFactory (see File-&gt;Examples).\nimport sys\n\nsys.path.append(\n    r\"C:\\Program Files\\DIgSILENT\\PowerFactory 2023 SP5\\Python\\3.11\"\n)  # you may use a different directory\n# Get the PF app\nimport powerfactory\n\napp = powerfactory.GetApplication()\nfrom powfacpy.applications.plots import Plots\n\napp.Show()\napp.ActivateProject(\n    r\"powfacpy\\39_bus_new_england_copy_where_tests_run\"\n)  # You may change the project path.\n\npfplt = Plots(app)\nstudy_case = pfplt.act_prj.activate_study_case(\n    r\"Study Cases\\2.1 Simulation Fault Bus 16 Stable\"\n)"
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "href": "tutorials/simulation_and_plotting.html#export-to-pandas-dataframe",
    "title": "Simulation and Plotting",
    "section": "3.1 Export to Pandas DataFrame",
    "text": "3.1 Export to Pandas DataFrame\nLet’s export dynamic simulation results to a Pandas DataFrame. We’ll hide the PowerFactory app to improve the performance.\n\ntry:\n    app.Hide()\n    pfds.act_prj.clear_elmres()\n    pfds.act_prj.add_results_variable(\n        [\n            r\"Network Model\\Network Data\\Grid\\G 01\",\n            r\"Network Model\\Network Data\\Grid\\G 02\",\n        ],\n        [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value],\n    )\n    pfds.initialize_and_run_sim()\n    df_sim_res = pfres.export_to_pandas()\nfinally:\n    app.Show()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\nGrid\\G 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nMulti index column labels are used by default. The first index is the path of the object inside the network data folder and the second index is the variable name.\nYou can also use single index column format:\n\npfres.multi_index_labels = False\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nGrid\\G 01\\s:P1\nGrid\\G 01\\s:Q1\nGrid\\G 02\\s:P1\nGrid\\G 02\\s:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nIt is also possible to set the actual PF objects as labels:\n\npfres.pf_objects_in_labels = True\npfres.multi_index_labels = True\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 01.ElmSym&lt;/l3&gt;\n&lt;l3&gt;\\seberlein.IntUser\\powfacpy\\39_bus_new_england_copy_where_tests_run.IntPrj\\Network Model.IntPrjfolder\\Network Data.IntPrjfolder\\Grid.ElmNet\\G 02.ElmSym&lt;/l3&gt;\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\nThe column headers are the path of the objects relative to the network data folder (by default) together with the result variable name. You can change the relative path by setting the attribute pfres.truncate_paths_until (relative to active project):\n\npfres.multi_index_labels = True\npfres.pf_objects_in_labels = False\npfres.truncate_paths_until = \"Network Model\\\\Network Data\\\\Grid\\\\\"\ndf_sim_res = pfres.export_to_pandas()\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\nG 02\n\n\n\ns:P1\ns:Q1\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.09\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n-0.08\n1000.0\n88.281415\n520.811072\n198.251784\n\n\n\n\n\n\n\npowfacpy offers methods to easily extract results from the exported pandas DataFrame using PowerFactory objects instead of columns headers (note that changing the format of the column headers of the DataFrame after export will break this functionality):\n\nimport matplotlib.pyplot as plt\n\np_g_01 = pfres.get_simulation_results_from_dataframe(\n    df_sim_res,\n    g_01,  # accepts using PF objects of their path inside the active project)\n    RMS_bal.ElmSym.s_P1.value,\n)\np_g_01.plot(grid=True)\np_g_01.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\n\n\ntime\n\n\n\n\n\n-0.10\n1000.0\n\n\n-0.09\n1000.0\n\n\n-0.08\n1000.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s look a more complicated example where you want to examine the active and reactive power of the synchronous machines G 01 and G 02.\n\n# SM objects\nsm_objs = [\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 01\"),\n    pfres.act_prj.get_unique_obj(r\"Network Model\\Network Data\\Grid\\G 02\"),\n]\n\n# Results variables\nsm_res_var = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\n\npfres.act_prj.clear_elmres()\npfres.act_prj.add_results_variable(sm_objs, sm_res_var)\npfdi = DynamicSimulation(app)\npfdi.initialize_and_run_sim()\n\nWe want to add a legend to the plots. As the default variable and object names might not be very descriptive, powfacpy allows to define aliases, e.g. to be used later for labels in plots:\n\npfres.variable_aliases = {\n    RMS_bal.ElmSym.s_P1.value: \"Active Power\",\n    RMS_bal.ElmSym.s_Q1.value: \"Reactive Power\",\n}  # note that RMS_bal.ElmSym.s_P1.value gives 's:P1'\n\npfres.obj_aliases = {\n    \"G 01\": \"Synch. Maschine 1 (large)\",\n    \"G 02\": \"Synch. Maschine 2\",\n}\n\nLet’s see how the variable_aliases dictionary can then be used when plotting active and reactive power of G 01 using replace_variable_aliases:\n\ndf_sim_res = pfres.export_to_pandas()\nfor var in sm_res_var:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm_objs[0], var)\n    label = pfres.replace_variable_aliases(var)\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nInstead of s:P1 or s:Q1, the replacements defined in the dictionaries above are used for the labels.\nOr in a similar fashion, using also the object_aliases to plot the reactive power of both machines:\n\nvar = RMS_bal.ElmSym.s_P1.value\nfor sm in sm_objs:\n    res = pfres.get_simulation_results_from_dataframe(df_sim_res, sm, var)\n    label = (\n        pfres.replace_object_aliases(sm.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res, label=label)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nHence, the dictionaries are a clean option to define aliases and reuse them anywhere in your code.\nNote that get_simulation_results_from_dataframe also accepts a list of objects (as well as a list of variables). You can easily get various time series results and then process the data using pandas (e.g. calculate mean or average):\n\nvar = RMS_bal.ElmSym.s_P1.value\nres = pfres.get_simulation_results_from_dataframe(\n    df_sim_res, sm_objs, var  # list with G 01 and G 02\n)\n\nmean = res.mean(1)  # pandas method to get mean over axis 1\nsum = res.sum(1)\n\n# Plot active power of individual SMs\nfor sm_num, sm_obj in enumerate(sm_objs):\n    label = (\n        pfres.replace_object_aliases(sm_obj.loc_name)\n        + \" | \"\n        + pfres.replace_variable_aliases(var)\n    )\n    plt.plot(res.iloc[:, sm_num], label=label)\n\n# Plot mean and sum\nlabel_sms = \", \".join([pfres.replace_object_aliases(sm.loc_name) for sm in sm_objs])\nlabel = \"MEAN of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(mean, label=label)\nlabel = \"SUM of \" + label_sms + \" | \" + pfres.replace_variable_aliases(var)\nplt.plot(sum, label=label)\nplt.legend(loc=\"lower center\", bbox_to_anchor=(0.5, 1.0))\nplt.grid()\n\n\n\n\n\n\n\n\nNote that the same code block can be used with other result variables (e.g. reactive power) just by changing the var assignment in the first line.\nBy default, export_to_pandas exports all monitored variables of the first ElmRes object found in the active study case. Alternatively, selections of network elements and the respective variables as well as results objects (ElmRes) can be specified as lists:\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\ndf_sim_res = pfres.export_to_pandas(\n    list_of_results_objs=elmres_list, elements=elements, variables=variables\n)\ndf_sim_res.head(3)\n\n\n\n\n\n\n\n\nG 01\n\n\n\ns:P1\ns:Q1\n\n\ntime\n\n\n\n\n\n\n-0.10\n1000.0\n88.281415\n\n\n-0.09\n1000.0\n88.281415\n\n\n-0.08\n1000.0\n88.281415"
  },
  {
    "objectID": "tutorials/simulation_and_plotting.html#export-to-csv-format",
    "href": "tutorials/simulation_and_plotting.html#export-to-csv-format",
    "title": "Simulation and Plotting",
    "section": "3.2 Export to CSV Format",
    "text": "3.2 Export to CSV Format\nWe can also export simulation results from PowerFactory to a csv file. The syntax is very simlar to the export to pandas:\n\npfres.export_to_csv()\n\n'd:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\results.csv'\n\n\nThis exports all variables from the first result object (ElmRes) found in the active study case to the directory from where the script is run. You can also specifiy a directory, a file name (default is “results”) and lists for grid objects, variables and results objects (similar to the method export_to_pandas).\n\nelements = [g_01, g_01]\nvariables = [RMS_bal.ElmSym.s_P1.value, RMS_bal.ElmSym.s_Q1.value]\nelmres_list = [pfres.act_prj.get_results_obj_from_initial_conditions_calc()] * len(\n    variables\n)\n\npfres.export_to_csv(\n    file_name=\"Power of Synchronous Machine 01\",\n    list_of_results_objs=elmres_list,\n    elements=elements,\n    variables=variables,\n)\n\n'd:\\\\User\\\\seberlein\\\\FraunhIEE-UniKassel-PowSysStability\\\\powfacpy\\\\docs\\\\tutorials\\\\Power of Synchronous Machine 01.csv'\n\n\nThe static method plot_from_csv pf Plots class is used to plot from files of this format:\n\nfrom powfacpy.applications.plots import Plots\n\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:P1\")\nplot = Plots.plot_from_csv(\"Power of Synchronous Machine 01.csv\", \"G 01\\s:Q1\")\nplt.grid()\n\n\n\n\n\n\n\n\nPyplot is used by default, but you can specify a different plot interface using the optional argument plot_interface."
  }
]